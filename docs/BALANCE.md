# Balance Analysis

> Generated from sim_bench runs on 2026-02-24.
> Baseline and balance_v1 scenarios, 5 seeds each, 20,160 ticks (2 weeks sim-time).

## 1. Current State Analysis (Baseline)

### Critical Finding: The Sim Is Deadlocked

Both baseline and balance_v1 produce **zero ore mined** across all seeds over 2 weeks.
The ship surveys endlessly but never transitions to mining. Root cause is a dependency chain
with no bootstrap path:

```
Mine requires → knowledge.composition (set by DeepScan)
DeepScan requires → tech_deep_scan_v1 unlocked
tech_deep_scan_v1 requires → 100 Exploration domain points
Domain points require → Exploration Lab installed and running
Exploration Lab requires → module_exploration_lab in station inventory
Initial state has → no labs, no refinery, no assembler
```

The autopilot correctly prioritizes: deposit → mine → deepscan → survey. But with no labs
in the initial loadout, research never produces domain points, the deep scan tech never
unlocks, and the ship falls through to survey every cycle.

**Note:** `content/dev_base_state.json` provides a better starting loadout (refinery,
assembler, maintenance bay, 500 kg Fe, 10 repair kits) but sim_bench currently hardcodes
`build_initial_state()` and does not support loading a custom state file. Even
`dev_base_state.json` is missing labs, so the deep scan deadlock would persist.
Adding `--state` / `"state"` support to sim_bench scenarios is a prerequisite for testing
with the dev state.

### What the Ship Actually Does (Seed 1)

| Phase | Ticks | Activity |
|---|---|---|
| 0–120 | Survey site (120 ticks) |
| 120–180 | Transit to discovered asteroid's node |
| 180+ | Alternating survey/transit for remaining sites |
| End state | 4 asteroids discovered, 16 scan sites remaining, 260 scan data accumulated |

The scan data accumulates sim-wide but has nowhere to go — no lab to consume it.

### Baseline Metrics (5-seed average)

| Metric | Mean | Notes |
|---|---|---|
| total_ore_kg | 0 | No mining occurs |
| total_material_kg | 0 | No refinery (not installed) |
| asteroids_discovered | 4.2 | Surveys work fine |
| asteroids_depleted | 0 | Nothing mined |
| techs_unlocked | 0 | No labs → no research |
| total_scan_data | ~260 | Generated by surveys, never consumed |
| avg_module_wear | 0 | Only maintenance bay installed (0 wear_per_run) |
| repair_kits_remaining | 5 | Untouched |
| station_storage_used_pct | 5% | Just the initial repair kits |
| fleet_idle | 0 | Ship always busy surveying/transiting |
| collapse_rate | 0/5 | Can't collapse if nothing runs |

### balance_v1 Results

Identical to baseline — the constant overrides (asteroid mass, cargo capacity, mining rate)
have zero effect because the sim never reaches the mining phase. The larger station cargo
(2000 m³) shows as 0.25% storage used instead of 5%, but that's the only difference.

---

## 2. Blocking Issue: Initial State Needs Labs + Bench Needs State Loading

There are two related problems:

### Problem A: sim_bench doesn't support custom state files

`sim_bench` hardcodes `build_initial_state()` (from sim_world) which creates a minimal
station with only a maintenance bay. Meanwhile, `content/dev_base_state.json` exists with
a much better loadout:

| What `dev_base_state.json` has | What `build_initial_state()` has |
|---|---|
| Refinery (`module_basic_iron_refinery`) | — |
| Assembler (`module_basic_assembler`) | — |
| Maintenance bay | Maintenance bay |
| 500 kg Fe material | — |
| 10 repair kits | 5 repair kits |
| No labs | No labs |

**Recommendation:** Add a `"state"` field to the scenario JSON schema so bench can load
`dev_base_state.json` (or any custom state). This unblocks testing with the intended
starting loadout.

### Problem B: Neither starting state includes labs

Both `dev_base_state.json` and `build_initial_state()` are missing exploration and materials
labs. Without an exploration lab, scan data from surveys accumulates but never converts to
domain points, so `tech_deep_scan_v1` never unlocks, and mining never begins.

### Recommended Starting Loadout

Add to `dev_base_state.json` (and `build_initial_state()` for parity):

| Module | Status | Rationale |
|---|---|---|
| `module_basic_iron_refinery` | Already in dev_base_state | Process ore → material |
| `module_basic_assembler` | Already in dev_base_state | Produce repair kits |
| `module_maintenance_bay` | Already in both | Repair worn modules |
| `module_exploration_lab` | **Missing — add** | Consumes ScanData → unlocks deep scan tech |
| `module_materials_lab` | **Missing — add** | Needed for Materials domain techs once mining starts |

This represents a freshly commissioned station: basic but functional. "Low-level equipment
that shouldn't be good" — the modules have high wear rates, slow intervals, and low output.
The limitation is performance, not absence.

### Alternative: "Mine Blind" Fallback

The engine already supports mining without `knowledge.composition` — `resolve_mine` falls
back to `true_composition`. The autopilot could be given a "mine blind" mode that mines
un-scanned asteroids when deep scan tech is unavailable. This would let the gameplay loop
start without labs, but feels wrong for a hard-sci-fi sim (mining random rocks with no
analysis).

**Recommendation:** Add the starting loadout rather than mine-blind. Hard sci-fi means
you analyze before you extract.

---

## 3. Proposed Constants Changes (Overridable)

These changes assume the starting loadout issue is fixed first.

### Changes with Rationale

| Constant | Current | Proposed | Rationale |
|---|---|---|---|
| `asteroid_mass_min_kg` | 100 | 500,000 | Current 100 kg is a basketball-sized rock. 500t (~7m dia S-type) is a real small asteroid. |
| `asteroid_mass_max_kg` | 100,000 | 10,000,000 | Current 100t is a large boulder. 10,000t (~20m dia) is still small but substantial for gameplay. |
| `station_cargo_capacity_m3` | 100 | 2,000 | 100 m³ = 5 ship holds. Constant overflow pressure. 2000 m³ gives breathing room for batch processing. |
| `ship_cargo_capacity_m3` | 20 | 50 | 20 m³ is a cargo van. 50 m³ (shipping container) is appropriate for a starter mining shuttle. |
| `mining_rate_kg_per_tick` | 50 | 15 | 15 kg/min = 900 kg/hr = ~21.6 t/day. Filling a 50 m³ hold (~150t ore at ~3t/m³) takes ~7 days. Starter drill: slow but functional. |
| `deposit_ticks` | 60 | 120 | 2 hours to offload. Modest dock, manual handling. Makes depot trips meaningful. |
| `autopilot_refinery_threshold_kg` | 500 | 2,000 | Refinery batch is 1,000 kg input. Threshold at 2,000 kg ensures a batch is always ready with buffer. |

### Constants Kept As-Is

| Constant | Value | Rationale |
|---|---|---|
| `travel_ticks_per_hop` | 2,880 (2 days) | Already appropriate for belt transit. "Traveling to an asteroid should take days." |
| `survey_scan_ticks` | 120 (2 hours) | Reasonable survey duration for starter equipment. |
| `deep_scan_ticks` | 480 (8 hours) | Intensive analysis — appropriate for hard sci-fi. |
| `research_roll_interval_ticks` | 60 (1 hour) | Research check frequency. OK as-is. |
| `data_generation_*` | peak=100, floor=5, decay=0.7 | Survey data generation. Needs testing once labs work. |
| Wear thresholds | 0.5/0.8 | Band thresholds seem reasonable. |

---

## 4. Module-Level Recommendations (Requires Content File Changes)

These cannot be tested via the override system. They require changes to `content/module_defs.json`.

### Refinery: `module_basic_iron_refinery`

| Parameter | Current | Proposed | Rationale |
|---|---|---|---|
| `processing_interval_ticks` | 60 (1 hr) | 180 (3 hrs) | Starter refinery is slow. 3 hours per batch of 1,000 kg ore means ~8 batches/day. With larger asteroids, this creates meaningful processing time. |
| `wear_per_run` | 0.01 | 0.01 | Keep. 100 runs to failure = ~12.5 days at full utilization. Creates maintenance pressure. |

### Labs: `module_exploration_lab` / `module_materials_lab`

| Parameter | Current | Proposed | Rationale |
|---|---|---|---|
| `research_interval_ticks` | 1 | 10 | Labs running every single tick is absurdly fast and burns through wear in minutes. Every 10 min is still active but sustainable. |
| `wear_per_run` | 0.005 | 0.002 | At interval=1: 200 ticks to failure (3.3 hours). At interval=10 + wear=0.002: 5,000 ticks (3.5 days). Much more reasonable. |
| `data_consumption_per_run` | 10/8 | 10/8 | Keep. Consumption rate is fine if interval slows down. |

### Assembler: `module_basic_assembler`

| Parameter | Current | Proposed | Rationale |
|---|---|---|---|
| `assembly_interval_ticks` | 120 (2 hrs) | 240 (4 hrs) | Repair kits should be scarce and valuable. 6 per day vs 12 per day. |
| `wear_per_run` | 0.008 | 0.008 | Keep. 125 runs to failure = ~20.8 days at interval=240. Reasonable. |

### Recipe Scaling

With much larger asteroids (500t–10,000t), recipe input amounts may need adjustment:

| Recipe | Current Input | Consider | Rationale |
|---|---|---|---|
| `recipe_basic_iron` | 1,000 kg ore | Keep initially | Test first. With 15 kg/min mining, accumulating 1,000 kg takes ~67 min. Reasonable batch size. |
| `recipe_basic_repair_kit` | 100 kg Fe | Keep initially | Depends on Fe yield from refinery. Test once loop works. |

---

## 5. Recommendations for New Overridable Constants

The current override system only covers `Constants` struct fields. Several module-level
parameters significantly affect game balance but can't be tested without editing content
JSON files directly. Adding these as overridable would greatly improve the bench workflow.

### High Priority — Directly Affects Core Gameplay Loop

| Proposed Override | Current Location | Why |
|---|---|---|
| `refinery_processing_interval_ticks` | `module_defs.json` → Processor behavior | Controls throughput of the entire material pipeline. Key balance lever. |
| `lab_research_interval_ticks` | `module_defs.json` → Lab behavior | Controls research speed and lab wear rate. Currently 1 (every tick), needs tuning. |
| `assembler_assembly_interval_ticks` | `module_defs.json` → Assembler behavior | Controls repair kit production rate. Sustainability balance. |

These would apply as multipliers or direct overrides to all modules of that type,
enabling bench scenarios to test different processing speeds without editing content files.

### Medium Priority — Wear and Sustainability

| Proposed Override | Current Location | Why |
|---|---|---|
| `lab_wear_per_run` | `module_defs.json` → Lab behavior | Lab wear is the primary limiter on research progress. Needs tuning. |
| `processor_wear_per_run` | `module_defs.json` → Processor behavior | Refinery wear determines maintenance pressure. |
| `assembler_wear_per_run` | `module_defs.json` → Assembler behavior | Assembler wear affects repair kit self-sufficiency. |
| `maintenance_wear_reduction_per_run` | `module_defs.json` → Maintenance behavior | How fast repairs happen. Currently 0.2 per run — might be too generous or too stingy. |

### Lower Priority — Research Tuning

| Proposed Override | Current Location | Why |
|---|---|---|
| `tech_difficulty_multiplier` | Would apply to all techs | Global difficulty scaling without editing each tech. |
| `domain_requirement_multiplier` | Would apply to all techs | Scale how many domain points are needed. |
| `lab_data_consumption_per_run` | `module_defs.json` → Lab behavior | How fast labs consume raw data. |

### Implementation Approach

The cleanest approach would be to add an `overrides` layer in `apply_overrides()` that
mutates `GameContent.module_defs` after loading, using the same pattern as the existing
`Constants` overrides. The override keys would be namespaced:

```json
{
  "overrides": {
    "station_cargo_capacity_m3": 2000.0,
    "module.processor.processing_interval_ticks": 180,
    "module.lab.research_interval_ticks": 10,
    "module.lab.wear_per_run": 0.002,
    "module.assembler.assembly_interval_ticks": 240
  }
}
```

This keeps the flat override map but uses dotted keys to target module parameters.
The `apply_overrides` function would route `module.*` keys to content mutation.

---

## 6. Design Principles for Future Balancing

### "Hard Sci-Fi With Gameplay Concessions"

**Hard sci-fi means:**
- Asteroid masses reflect real objects (not 100 kg boulders)
- Travel takes days, not minutes
- You analyze before you extract (deep scan before mining)
- Equipment degrades and needs maintenance
- Research is slow and probabilistic

**Gameplay concessions mean:**
- Single-ship operations work (real asteroid mining would need fleets)
- Starter equipment is bad but functional (not absent)
- Time scales are compressed vs reality but still feel weighty
- The player sees meaningful progress within a play session (~2-4 hours = 120-240 ticks)

### Pacing Targets (1 tick = 1 minute)

| Activity | Target Duration | Rationale |
|---|---|---|
| Transit to asteroid | 2–4 days (2,880–5,760 ticks) | Belt distances. Current 2-day hop is good. |
| Survey a site | 2 hours (120 ticks) | Quick reconnaissance scan. |
| Deep scan an asteroid | 8 hours (480 ticks) | Detailed spectral analysis. |
| Fill ship cargo hold | 5–10 days | Starter drill is slow. This is the grind. |
| Refinery batch | 3 hours (180 ticks) | Slow starter processor. |
| Research a basic tech | 1–2 weeks | The first unlock should feel earned. |
| Repair kit production | 4 hours (240 ticks) | Scarce but achievable. |

### Balance Levers (Ranked by Impact)

1. **Initial loadout** — What modules the station starts with. This is gate zero.
2. **Mining rate** — How fast ore accumulates. The fundamental economic input.
3. **Travel time** — How much of the ship's time is "wasted" in transit.
4. **Processing intervals** — How fast the station converts ore → material → components.
5. **Research speed** — Lab interval × data availability × tech difficulty.
6. **Wear rates** — How fast equipment degrades. The sustainability pressure.
7. **Cargo capacities** — How much can move per trip. Affects mining trip duration.

### Next Steps

1. **Add labs to `dev_base_state.json`** — exploration lab + materials lab to unblock research
2. **Add `"state"` support to sim_bench** — Load custom state files from scenario JSON
3. **Update `build_initial_state()`** — Match `dev_base_state.json` loadout for parity
4. **Re-run baseline** — Verify the gameplay loop actually functions end-to-end
5. **Apply constant overrides** — Test `balance_v1` with a working loop
6. **Add module-level overrides** — Enable testing processing intervals, wear rates, etc.
7. **Iterate** — Run longer scenarios (30-day, 90-day) to test sustainability and research pacing
