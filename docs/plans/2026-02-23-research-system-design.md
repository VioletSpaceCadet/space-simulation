# Research System Design

## Goal

Replace the current minimal research system (auto-split evidence, probabilistic unlock) with a richer lab-based system where labs are station modules that consume raw data and produce domain-specific research points toward tech unlocks.

## Architecture

Labs are a new module behavior type (alongside Processor, Assembler, Maintenance). They integrate into the existing station module tick pipeline. Raw data is a sim-wide resource generated by gameplay events with configurable diminishing returns. Research domains accumulate points per tech. Tech unlock uses a probabilistic model where accumulated domain sufficiency drives the probability curve toward near-certainty.

## Raw Data System

### Data as sim-wide resource

Raw data lives on `ResearchState`, not in station inventory. Data is knowledge, not cargo — it doesn't take up storage or require transport.

```rust
pub struct ResearchState {
    pub unlocked: HashSet<TechId>,
    pub evidence: HashMap<TechId, DomainProgress>,
    pub data_pool: HashMap<DataKind, f32>,
    pub action_counts: HashMap<String, u64>,
}
```

### Data kinds

```rust
pub enum DataKind {
    ScanData,         // from surveying, deep scanning
    MiningData,       // from mining operations
    EngineeringData,  // from assembling components
}
```

### Data generation

Events that produce data:

| Event | Action Key | DataKind |
|---|---|---|
| OreMined | `mine_{template_id}` | MiningData |
| SurveyCompleted | `survey` | ScanData |
| DeepScanCompleted | `deep_scan` | ScanData |
| AssemblerRan | `assemble_{recipe_id}` | EngineeringData |

Data is added to `research_state.data_pool[kind]` and the action counter increments when the event fires.

### Diminishing returns

Yield per action: `amount = floor + (peak - floor) * decay_rate ^ count`

Constants (all configurable in `constants.json`):

```json
"data_generation_peak": 100.0,
"data_generation_floor": 5.0,
"data_generation_decay_rate": 0.7
```

Example: 1st=100, 2nd=72, 5th=27, 10th=8, 20th=5.1 (floor).

Tracked per action-type globally (not per specific target). Counter key format: `mine_iron_rich`, `survey`, `assemble_recipe_basic_repair_kit`.

### No time-based decay (MVP)

Data does not decay over time. The diminishing returns floor already prevents infinite value accumulation. Time-based decay can be added later if needed.

## Labs

### Module behavior definition

```rust
Lab {
    domain: ResearchDomain,
    data_consumption_per_run: f32,
    research_points_per_run: f32,
    accepted_data: Vec<DataKind>,
    research_interval_ticks: u64,
}
```

### Lab state

```rust
pub struct LabState {
    pub ticks_since_last_run: u64,
    pub assigned_tech: Option<TechId>,
    pub starved: bool,
}
```

### Lab tick behavior

1. Check enabled, power budget, interval timer
2. Check `assigned_tech` is set and not already unlocked
3. Look for accepted data in `research_state.data_pool`
4. If sufficient data: consume `data_consumption_per_run`, produce `research_points_per_run * wear_efficiency` domain points on assigned tech
5. If partial data available: consume what exists, produce proportionally reduced points
6. If no data: set `starved = true` (transition event only), skip production
7. Accumulate wear

### Commands and events

New command: `AssignLabTech { station_id, module_id, tech_id: Option<TechId> }`

New events:
- `LabRan { station_id, module_id, tech_id, data_consumed, points_produced, domain }`
- `LabStarved { station_id, module_id }` (transition only)
- `LabResumed { station_id, module_id }` (transition only)

### Tick integration

Labs tick in the station module phase (step 3), after assemblers, before maintenance. This ordering:
- Processors (3a) and assemblers (3b) may generate data via events
- Labs (3c) consume that data
- Maintenance (3d) repairs worn labs
- Research roll (step 4) uses accumulated points

## Research Domains

Three base domains:

```rust
pub enum ResearchDomain {
    Materials,
    Exploration,
    Engineering,
}
```

Extensible via enum variant addition. Domain points accumulate per-tech via `DomainProgress`:

```rust
pub struct DomainProgress {
    pub points: HashMap<ResearchDomain, f32>,
}
```

## Technologies

### Tech definition

```rust
pub struct TechDef {
    pub id: TechId,
    pub name: String,
    pub prereqs: Vec<TechId>,
    pub domain_requirements: HashMap<ResearchDomain, f32>,
    pub difficulty: f32,
    pub accepted_data: Vec<DataKind>,
    pub effects: Vec<TechEffect>,
}
```

### Unlock model (probabilistic with domain sufficiency)

Research roll runs every N ticks (configurable, default 60).

For each eligible tech (prereqs met, not unlocked):

1. Compute per-domain ratio: `ratio_d = min(accumulated_d / required_d, 1.0)` for each domain d
2. Compute overall sufficiency: geometric mean of all ratios
   - `sufficiency = (ratio_1 * ratio_2 * ... * ratio_n) ^ (1/n)`
   - This penalizes under-allocation in any single domain
3. Compute effective progress: `effective = sufficiency * sum(all_accumulated_points)`
4. Compute unlock probability: `p = 1 - e^(-effective / difficulty)`
5. Roll: if `rng.gen() < p`, unlock

Behavior:
- All domains met, total points ~= difficulty: p ~ 63%
- All domains met, total points ~= 3x difficulty: p ~ 95% (near-inevitable)
- One domain at 50%: sufficiency drops, effective halved, much slower
- Zero progress in any required domain: sufficiency = 0, p = 0 (never unlocks)

### Under-allocation penalty

The geometric mean creates smooth nonlinear penalty. 50% in one domain with 100% in another:
- Geometric mean: sqrt(0.5 * 1.0) = 0.71
- Effective progress reduced to 71% of total
- Much worse than linear average (75%)

### Over-allocation diminishing returns

The exponential CDF naturally provides diminishing returns. Going from 50% to 100% of difficulty increases p from ~39% to ~63%. Going from 100% to 200% only increases from ~63% to ~86%. The curve flattens.

## Content

### New module definitions (module_defs.json)

Materials Lab:
- Domain: Materials
- Accepted data: MiningData, EngineeringData
- Consumption: 10.0/run, Output: 5.0 points/run
- Interval: 1 tick
- Power: 12.0/run, Wear: 0.005/run
- Mass: 4000kg, Volume: 8m3

Exploration Lab:
- Domain: Exploration
- Accepted data: ScanData
- Consumption: 8.0/run, Output: 4.0 points/run
- Interval: 1 tick
- Power: 10.0/run, Wear: 0.005/run
- Mass: 3500kg, Volume: 7m3

### Updated tech definitions (techs.json)

`tech_deep_scan_v1`: domain_requirements = { Exploration: 100.0 }

Add 1-2 new techs to exercise multi-domain requirements.

### New constants (constants.json)

```json
"research_roll_interval_ticks": 60,
"data_generation_peak": 100.0,
"data_generation_floor": 5.0,
"data_generation_decay_rate": 0.7
```

## Tick Order (updated)

1. Apply commands (including AssignLabTech)
2. Resolve ship tasks (mining/survey/scan generate data events)
3. Tick station modules:
   a. Processors
   b. Assemblers (engineering data events)
   c. Labs (consume data, produce domain points)
   d. Maintenance (repairs)
4. Advance research (roll every N ticks using accumulated domain points)
5. Replenish scan sites
6. Increment tick

## Autopilot Updates

- Auto-install lab modules from station inventory
- Auto-assign unassigned labs to highest-priority eligible tech matching the lab's domain
- Priority: techs closest to unlock (highest sufficiency) first

## UI Considerations

Backend exposes via existing snapshot:
- `research_state.data_pool` — raw data levels
- `research_state.evidence` — per-tech domain progress
- Lab module state (assigned tech, starved status)

Frontend ResearchPanel updates:
- Show raw data pool levels
- Show per-tech domain progress bars with requirement thresholds
- Show assigned labs per tech
- Add tech selection (assign lab to tech via command)

## File Placement

| Change | File |
|---|---|
| LabState, ResearchDomain, DataKind extension, DomainProgress | types.rs |
| Lab tick logic (tick_lab_modules) | station.rs |
| Updated advance_research (batch roll, domain sufficiency) | research.rs |
| Data generation on events | engine.rs |
| AssignLabTech command handling | engine.rs |
| Lab content definitions | content/module_defs.json |
| Tech domain requirements | content/techs.json |
| New constants | content/constants.json |
| Autopilot lab management | sim_control/src/lib.rs |
| UI research panel | ui_web/ |

## Edge Cases

- Lab assigned to already-unlocked tech: skip, produce nothing. Autopilot should reassign.
- Lab assigned to tech with unmet prereqs: skip. Autopilot shouldn't assign these.
- No data available: lab starves, emits transition event, resumes when data appears.
- All data consumed by one lab, other labs starve: first-by-sorted-ID wins (determinism).
- Tech with zero difficulty: unlocks on first roll with any progress.
- Tech with domain requirement in a domain no lab covers: can never unlock (intentional — need the right lab).

## Extensibility Notes

The design supports future additions without structural changes:
- **Multiple raw data types**: already an enum, add variants
- **Domain-specific labs**: already domain-affinity, add more lab module defs
- **Research events/bursts**: add data directly to pool from event handlers
- **Research milestones**: check domain thresholds, emit events
- **Heat/money/political constraints**: add to lab tick checks alongside power
- **Upgrade tiers**: different lab module defs with better rates
