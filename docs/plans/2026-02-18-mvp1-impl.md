# MVP-1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add `sim_daemon` (axum HTTP server with SSE stream) and a Vite + React + TypeScript mission control UI that observes the running simulation in real-time.

**Architecture:** `sim_daemon` runs the tick loop in a dedicated tokio task. State is shared via `Arc<Mutex<SimState>>`; events are broadcast via `tokio::sync::broadcast`. Three axum endpoints serve meta, snapshot, and SSE stream. The React app hydrates from the snapshot endpoint on load, then receives live updates via `EventSource`.

**Tech Stack:** Rust / axum 0.7 / tokio 1 / async-stream; React 18 / TypeScript 5 / Vite 5 / Vitest / React Testing Library.

---

## Task 1: Add sim_daemon crate to workspace

**Files:**
- Modify: `Cargo.toml` (workspace root)
- Create: `crates/sim_daemon/Cargo.toml`
- Create: `crates/sim_daemon/src/main.rs`

**Step 1: Add "crates/sim_daemon" to workspace members in `Cargo.toml`**

```toml
members = ["crates/sim_core", "crates/sim_control", "crates/sim_cli", "crates/sim_daemon"]
```

**Step 2: Create `crates/sim_daemon/Cargo.toml`**

```toml
[package]
name = "sim_daemon"
version = "0.1.0"
edition = "2021"

[dependencies]
sim_core = { path = "../sim_core" }
sim_control = { path = "../sim_control" }
tokio = { version = "1", features = ["full"] }
axum = "0.7"
tower-http = { version = "0.5", features = ["cors"] }
async-stream = "0.3"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
rand = "0.8"
rand_chacha = "0.3"
anyhow = "1"
clap = { version = "4", features = ["derive"] }

[dev-dependencies]
tower = { version = "0.4", features = ["util"] }
http-body-util = "0.1"
```

**Step 3: Create stub `crates/sim_daemon/src/main.rs`**

```rust
fn main() {
    println!("sim_daemon stub");
}
```

**Step 4: Verify it builds**

```bash
cargo build -p sim_daemon
```

Expected: compiles with no errors.

**Step 5: Commit**

```bash
git add Cargo.toml crates/sim_daemon/
git commit -m "feat: scaffold sim_daemon crate"
```

---

## Task 2: Content loading + world gen in sim_daemon

**Files:**
- Modify: `crates/sim_daemon/src/main.rs`

Note: this duplicates logic from `sim_cli`. Intentional for MVP-1; factor out later.

**Step 1: Replace stub main.rs with imports + load_content + build_initial_state**

```rust
use std::path::Path;

use anyhow::{Context, Result};
use rand::Rng;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use serde::Deserialize;
use sim_control::AutopilotController;
use sim_core::{
    AsteroidTemplateDef, Constants, Counters, FacilitiesState, GameContent, GameState, MetaState,
    NodeId, PrincipalId, ResearchState, ScanSite, ShipId, ShipState, SiteId, SolarSystemDef,
    StationId, StationState, TechDef,
};

#[derive(Deserialize)]
struct TechsFile {
    content_version: String,
    techs: Vec<TechDef>,
}

#[derive(Deserialize)]
struct AsteroidTemplatesFile {
    templates: Vec<AsteroidTemplateDef>,
}

fn load_content(content_dir: &str) -> Result<GameContent> {
    let dir = Path::new(content_dir);
    let constants: Constants = serde_json::from_str(
        &std::fs::read_to_string(dir.join("constants.json")).context("reading constants.json")?,
    )
    .context("parsing constants.json")?;
    let techs_file: TechsFile = serde_json::from_str(
        &std::fs::read_to_string(dir.join("techs.json")).context("reading techs.json")?,
    )
    .context("parsing techs.json")?;
    let solar_system: SolarSystemDef = serde_json::from_str(
        &std::fs::read_to_string(dir.join("solar_system.json"))
            .context("reading solar_system.json")?,
    )
    .context("parsing solar_system.json")?;
    let templates_file: AsteroidTemplatesFile = serde_json::from_str(
        &std::fs::read_to_string(dir.join("asteroid_templates.json"))
            .context("reading asteroid_templates.json")?,
    )
    .context("parsing asteroid_templates.json")?;
    Ok(GameContent {
        content_version: techs_file.content_version,
        techs: techs_file.techs,
        solar_system,
        asteroid_templates: templates_file.templates,
        constants,
    })
}

fn build_initial_state(content: &GameContent, seed: u64, rng: &mut impl Rng) -> GameState {
    let earth_orbit = NodeId("node_earth_orbit".to_string());
    let c = &content.constants;
    let station_id = StationId("station_earth_orbit".to_string());
    let station = StationState {
        id: station_id.clone(),
        location_node: earth_orbit.clone(),
        power_available_per_tick: c.station_power_available_per_tick,
        facilities: FacilitiesState {
            compute_units_total: c.station_compute_units_total,
            power_per_compute_unit_per_tick: c.station_power_per_compute_unit_per_tick,
            efficiency: c.station_efficiency,
        },
    };
    let ship_id = ShipId("ship_0001".to_string());
    let owner = PrincipalId("principal_autopilot".to_string());
    let ship = ShipState {
        id: ship_id.clone(),
        location_node: earth_orbit.clone(),
        owner,
        task: None,
    };
    let node_ids: Vec<&NodeId> = content.solar_system.nodes.iter().map(|n| &n.id).collect();
    let mut scan_sites = Vec::new();
    let mut site_counter = 1u64;
    for template in &content.asteroid_templates {
        for _ in 0..c.asteroid_count_per_template {
            let node = node_ids[rng.gen_range(0..node_ids.len())].clone();
            scan_sites.push(ScanSite {
                id: SiteId(format!("site_{:04}", site_counter)),
                node,
                template_id: template.id.clone(),
            });
            site_counter += 1;
        }
    }
    GameState {
        meta: MetaState {
            tick: 0,
            seed,
            schema_version: 1,
            content_version: content.content_version.clone(),
        },
        scan_sites,
        asteroids: std::collections::HashMap::new(),
        ships: std::collections::HashMap::from([(ship_id, ship)]),
        stations: std::collections::HashMap::from([(station_id, station)]),
        research: ResearchState {
            unlocked: std::collections::HashSet::new(),
            data_pool: std::collections::HashMap::new(),
            evidence: std::collections::HashMap::new(),
        },
        counters: Counters {
            next_event_id: 0,
            next_command_id: 0,
            next_asteroid_id: 0,
        },
    }
}

fn main() {
    println!("sim_daemon stub");
}
```

**Step 2: Verify it builds**

```bash
cargo build -p sim_daemon
```

**Step 3: Commit**

```bash
git add crates/sim_daemon/src/main.rs
git commit -m "feat: add content loading and world gen to sim_daemon"
```

---

## Task 3: SimState, AppState, router skeleton, and handler tests

**Files:**
- Modify: `crates/sim_daemon/src/main.rs`

**Step 1: Write the failing tests first**

Add this test module to the bottom of `main.rs` (before or after `fn main`):

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::{body::Body, http::Request, http::StatusCode};
    use http_body_util::BodyExt;
    use tower::ServiceExt;

    fn make_test_state() -> AppState {
        let content = GameContent {
            content_version: "test".to_string(),
            techs: vec![],
            solar_system: SolarSystemDef {
                nodes: vec![NodeDef {
                    id: NodeId("node_test".to_string()),
                    name: "Test".to_string(),
                }],
                edges: vec![],
            },
            asteroid_templates: vec![],
            constants: Constants {
                survey_scan_ticks: 1,
                deep_scan_ticks: 1,
                survey_scan_data_amount: 1.0,
                survey_scan_data_quality: 1.0,
                deep_scan_data_amount: 1.0,
                deep_scan_data_quality: 1.0,
                survey_tag_detection_probability: 0.5,
                asteroid_count_per_template: 0,
                station_compute_units_total: 10,
                station_power_per_compute_unit_per_tick: 1.0,
                station_efficiency: 1.0,
                station_power_available_per_tick: 100.0,
            },
        };
        let mut rng = ChaCha8Rng::seed_from_u64(0);
        let game_state = build_initial_state(&content, 0, &mut rng);
        let (event_tx, _) = tokio::sync::broadcast::channel(64);
        AppState {
            sim: std::sync::Arc::new(std::sync::Mutex::new(SimState {
                game_state,
                content,
                rng,
                autopilot: AutopilotController,
                next_command_id: 0,
            })),
            event_tx,
        }
    }

    #[tokio::test]
    async fn test_meta_returns_200() {
        let app = make_router(make_test_state());
        let response = app
            .oneshot(
                Request::builder()
                    .uri("/api/v1/meta")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();
        assert_eq!(response.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_meta_contains_tick() {
        let app = make_router(make_test_state());
        let response = app
            .oneshot(
                Request::builder()
                    .uri("/api/v1/meta")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();
        let body = response.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
        assert_eq!(json["tick"], 0);
    }

    #[tokio::test]
    async fn test_snapshot_returns_200() {
        let app = make_router(make_test_state());
        let response = app
            .oneshot(
                Request::builder()
                    .uri("/api/v1/snapshot")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();
        assert_eq!(response.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_snapshot_is_valid_json() {
        let app = make_router(make_test_state());
        let response = app
            .oneshot(
                Request::builder()
                    .uri("/api/v1/snapshot")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();
        let body = response.into_body().collect().await.unwrap().to_bytes();
        let result: Result<serde_json::Value, _> = serde_json::from_slice(&body);
        assert!(result.is_ok(), "snapshot was not valid JSON: {:?}", body);
    }
}
```

**Step 2: Run tests — expect compile failure** (types don't exist yet)

```bash
cargo test -p sim_daemon
```

**Step 3: Add SimState, AppState, handlers, and make_router above `fn main`**

```rust
use std::sync::{Arc, Mutex};

use axum::{
    extract::State,
    http::{header, StatusCode},
    response::Json,
    routing::get,
    Router,
};
use sim_core::{EventEnvelope, NodeDef};
use tokio::sync::broadcast;

struct SimState {
    game_state: GameState,
    content: GameContent,
    rng: ChaCha8Rng,
    autopilot: AutopilotController,
    next_command_id: u64,
}

type SharedSim = Arc<Mutex<SimState>>;
type EventTx = broadcast::Sender<Vec<EventEnvelope>>;

#[derive(Clone)]
struct AppState {
    sim: SharedSim,
    event_tx: EventTx,
}

fn make_router(state: AppState) -> Router {
    Router::new()
        .route("/api/v1/meta", get(meta_handler))
        .route("/api/v1/snapshot", get(snapshot_handler))
        .route("/api/v1/stream", get(stream_handler))
        .with_state(state)
}

async fn meta_handler(State(app_state): State<AppState>) -> Json<serde_json::Value> {
    let sim = app_state.sim.lock().unwrap();
    Json(serde_json::json!({
        "tick": sim.game_state.meta.tick,
        "seed": sim.game_state.meta.seed,
        "content_version": sim.game_state.meta.content_version,
    }))
}

async fn snapshot_handler(
    State(app_state): State<AppState>,
) -> (StatusCode, [(header::HeaderName, &'static str); 1], String) {
    let sim = app_state.sim.lock().unwrap();
    let body = serde_json::to_string(&sim.game_state).unwrap_or_default();
    drop(sim);
    (StatusCode::OK, [(header::CONTENT_TYPE, "application/json")], body)
}

async fn stream_handler() -> StatusCode {
    StatusCode::NOT_IMPLEMENTED // filled in Task 4
}
```

**Step 4: Run tests until all 4 pass**

```bash
cargo test -p sim_daemon
```

Fix any compile errors (missing imports, wrong field names, etc.) before continuing.

**Step 5: Commit**

```bash
git add crates/sim_daemon/src/main.rs
git commit -m "feat: add AppState, meta+snapshot handlers, router, and tests"
```

---

## Task 4: SSE stream handler

**Files:**
- Modify: `crates/sim_daemon/src/main.rs`

**Step 1: Replace stub `stream_handler` with full SSE implementation**

Replace the existing `stream_handler` function:

```rust
use axum::response::sse::{Event, Sse};
use std::convert::Infallible;
use std::time::Duration;

async fn stream_handler(
    State(app_state): State<AppState>,
) -> Sse<impl futures_core::Stream<Item = Result<Event, Infallible>>> {
    let mut rx = app_state.event_tx.subscribe();
    let sim = app_state.sim.clone();

    let stream = async_stream::stream! {
        loop {
            tokio::select! {
                result = rx.recv() => {
                    match result {
                        Ok(events) if !events.is_empty() => {
                            let data = serde_json::to_string(&events).unwrap_or_default();
                            yield Ok(Event::default().data(data));
                        }
                        Ok(_) => {}
                        Err(broadcast::error::RecvError::Lagged(_)) => {}
                        Err(broadcast::error::RecvError::Closed) => break,
                    }
                }
                _ = tokio::time::sleep(Duration::from_secs(5)) => {
                    let tick = sim.lock().unwrap().game_state.meta.tick;
                    let heartbeat = serde_json::json!({"heartbeat": true, "tick": tick});
                    yield Ok(Event::default().data(heartbeat.to_string()));
                }
            }
        }
    };

    Sse::new(stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(30))
            .text("ping"),
    )
}
```

Also add `use futures_core;` if the compiler asks — it's a transitive dep of async-stream/axum.

**Step 2: Verify build and existing tests still pass**

```bash
cargo test -p sim_daemon
```

Expected: all 4 tests pass.

**Step 3: Commit**

```bash
git add crates/sim_daemon/src/main.rs
git commit -m "feat: implement SSE stream handler"
```

---

## Task 5: Tick loop + CORS + CLI + main

**Files:**
- Modify: `crates/sim_daemon/src/main.rs`

**Step 1: Add tick loop function**

```rust
use sim_control::CommandSource;
use sim_core::EventLevel;

async fn run_tick_loop(
    sim: SharedSim,
    event_tx: EventTx,
    ticks_per_sec: f64,
    max_ticks: Option<u64>,
) {
    let sleep_duration = if ticks_per_sec > 0.0 {
        Some(Duration::from_secs_f64(1.0 / ticks_per_sec))
    } else {
        None
    };

    loop {
        let start = std::time::Instant::now();

        let (events, done) = {
            let mut guard = sim.lock().unwrap();
            let commands = guard.autopilot.generate_commands(
                &guard.game_state,
                &guard.content,
                &mut guard.next_command_id,
            );
            let events = sim_core::tick(
                &mut guard.game_state,
                &commands,
                &guard.content,
                &mut guard.rng,
                EventLevel::Normal,
            );
            let done = max_ticks.map_or(false, |max| guard.game_state.meta.tick >= max);
            (events, done)
        };

        let _ = event_tx.send(events);

        if done {
            break;
        }

        if let Some(duration) = sleep_duration {
            let elapsed = start.elapsed();
            if elapsed < duration {
                tokio::time::sleep(duration - elapsed).await;
            }
        } else {
            tokio::task::yield_now().await;
        }
    }
}
```

**Step 2: Add CORS to make_router**

Update `make_router` to add the CORS layer:

```rust
use axum::http::Method;
use tower_http::cors::{Any, CorsLayer};

fn make_router(state: AppState) -> Router {
    let cors = CorsLayer::new()
        .allow_origin(
            "http://localhost:5173"
                .parse::<axum::http::HeaderValue>()
                .unwrap(),
        )
        .allow_methods([Method::GET])
        .allow_headers(Any);

    Router::new()
        .route("/api/v1/meta", get(meta_handler))
        .route("/api/v1/snapshot", get(snapshot_handler))
        .route("/api/v1/stream", get(stream_handler))
        .layer(cors)
        .with_state(state)
}
```

**Step 3: Add CLI and replace stub main with async main**

```rust
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "sim_daemon", about = "Space Industry Sim Daemon")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    Run {
        #[arg(long)]
        seed: u64,
        #[arg(long, default_value = "./content")]
        content_dir: String,
        #[arg(long, default_value_t = 3001)]
        port: u16,
        /// Ticks per second. 0 = as fast as possible.
        #[arg(long, default_value_t = 10.0)]
        ticks_per_sec: f64,
        #[arg(long)]
        max_ticks: Option<u64>,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Run {
            seed,
            content_dir,
            port,
            ticks_per_sec,
            max_ticks,
        } => {
            let content = load_content(&content_dir)?;
            let mut rng = ChaCha8Rng::seed_from_u64(seed);
            let game_state = build_initial_state(&content, seed, &mut rng);
            let (event_tx, _) = broadcast::channel::<Vec<EventEnvelope>>(256);
            let app_state = AppState {
                sim: Arc::new(Mutex::new(SimState {
                    game_state,
                    content,
                    rng,
                    autopilot: AutopilotController,
                    next_command_id: 0,
                })),
                event_tx: event_tx.clone(),
            };
            let router = make_router(app_state.clone());
            let addr = std::net::SocketAddr::from(([0, 0, 0, 0], port));
            let speed = if ticks_per_sec == 0.0 {
                "max".to_string()
            } else {
                format!("{} ticks/sec", ticks_per_sec)
            };
            println!("sim_daemon listening on http://localhost:{port}  speed={speed}");
            tokio::spawn(run_tick_loop(
                app_state.sim,
                event_tx,
                ticks_per_sec,
                max_ticks,
            ));
            let listener = tokio::net::TcpListener::bind(addr).await?;
            axum::serve(listener, router).await?;
        }
    }
    Ok(())
}
```

**Step 4: Run all tests**

```bash
cargo test -p sim_daemon
```

Expected: all 4 tests pass.

**Step 5: Smoke test the daemon manually**

In one terminal:
```bash
cargo run -p sim_daemon -- run --seed 42 --ticks-per-sec 10 --max-ticks 200
```

In a second terminal:
```bash
curl http://localhost:3001/api/v1/meta
curl http://localhost:3001/api/v1/snapshot | python3 -m json.tool | head -20
curl -N http://localhost:3001/api/v1/stream   # Ctrl-C after a few events
```

Expected: JSON responses, SSE events appearing.

**Step 6: Commit**

```bash
git add crates/sim_daemon/src/main.rs
git commit -m "feat: implement tick loop, CORS, CLI, and main for sim_daemon"
```

---

## Task 6: Scaffold ui_web with Vite

**Files:**
- Create: `ui_web/` (via npm)

**Step 1: Create Vite + React + TypeScript app**

From the repo root:
```bash
npm create vite@latest ui_web -- --template react-ts
```

**Step 2: Install production dependencies**

```bash
cd ui_web && npm install
```

**Step 3: Install test dependencies**

```bash
npm install --save-dev vitest @vitest/ui jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

**Step 4: Configure Vitest in `ui_web/vite.config.ts`**

Replace the contents of `vite.config.ts`:

```ts
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test-setup.ts',
  },
  server: {
    proxy: {
      '/api': 'http://localhost:3001',
    },
  },
})
```

**Step 5: Create `ui_web/src/test-setup.ts`**

```ts
import '@testing-library/jest-dom'
```

**Step 6: Add `test` and `test:watch` scripts to `ui_web/package.json`**

In the `"scripts"` section, add:
```json
"test": "vitest run",
"test:watch": "vitest"
```

**Step 7: Add `/// <reference types="vitest" />` to vite.config.ts if Vitest types aren't resolving**

At the top of `vite.config.ts`:
```ts
/// <reference types="vitest" />
```

**Step 8: Verify the app runs**

```bash
cd ui_web && npm run dev
```

Expected: "VITE ... ready" at http://localhost:5173.

**Step 9: Verify tests run with 0 tests**

```bash
cd ui_web && npm test
```

Expected: exits cleanly (0 test files).

**Step 10: Commit**

```bash
cd .. && git add ui_web/
git commit -m "feat: scaffold ui_web with Vite + React + TypeScript"
```

---

## Task 7: TypeScript types and API functions

**Files:**
- Create: `ui_web/src/types.ts`
- Create: `ui_web/src/api.ts`
- Create: `ui_web/src/api.test.ts`

**Step 1: Write failing tests**

Create `ui_web/src/api.test.ts`:

```ts
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { fetchMeta, fetchSnapshot } from './api'

describe('fetchSnapshot', () => {
  beforeEach(() => {
    global.fetch = vi.fn()
  })

  it('calls /api/v1/snapshot', async () => {
    const mock = { meta: { tick: 0, seed: 42, content_version: 'test' }, scan_sites: [], asteroids: {}, ships: {}, stations: {}, research: { unlocked: [], data_pool: {}, evidence: {} } }
    vi.mocked(global.fetch).mockResolvedValueOnce(new Response(JSON.stringify(mock)))
    await fetchSnapshot()
    expect(global.fetch).toHaveBeenCalledWith('/api/v1/snapshot')
  })

  it('returns parsed snapshot with correct tick', async () => {
    const mock = { meta: { tick: 42, seed: 1, content_version: '0.0.1' }, scan_sites: [], asteroids: {}, ships: {}, stations: {}, research: { unlocked: [], data_pool: {}, evidence: {} } }
    vi.mocked(global.fetch).mockResolvedValueOnce(new Response(JSON.stringify(mock)))
    const result = await fetchSnapshot()
    expect(result.meta.tick).toBe(42)
  })
})

describe('fetchMeta', () => {
  beforeEach(() => {
    global.fetch = vi.fn()
  })

  it('calls /api/v1/meta', async () => {
    vi.mocked(global.fetch).mockResolvedValueOnce(new Response(JSON.stringify({ tick: 0, seed: 1, content_version: 'test' })))
    await fetchMeta()
    expect(global.fetch).toHaveBeenCalledWith('/api/v1/meta')
  })
})
```

**Step 2: Run tests — expect "Cannot find module './api'"**

```bash
cd ui_web && npm test
```

**Step 3: Create `ui_web/src/types.ts`**

```ts
export interface MetaInfo {
  tick: number
  seed: number
  content_version: string
}

export interface FacilitiesState {
  compute_units_total: number
  power_per_compute_unit_per_tick: number
  efficiency: number
}

export interface StationState {
  id: string
  location_node: string
  power_available_per_tick: number
  facilities: FacilitiesState
}

export interface TaskState {
  kind: { Idle: Record<string, never> } | { Survey: { site: string } } | { DeepScan: { asteroid: string } }
  started_tick: number
  eta_tick: number
}

export interface ShipState {
  id: string
  location_node: string
  owner: string
  task: TaskState | null
}

export interface AsteroidKnowledge {
  // Each entry: ["IronRich", 0.85]
  tag_beliefs: [string, number][]
  composition: Record<string, number> | null
}

export interface AsteroidState {
  id: string
  location_node: string
  anomaly_tags: string[]
  knowledge: AsteroidKnowledge
}

export interface ScanSite {
  id: string
  node: string
  template_id: string
}

export interface ResearchState {
  unlocked: string[]
  data_pool: Record<string, number>
  evidence: Record<string, number>
}

export interface SimSnapshot {
  meta: MetaInfo
  scan_sites: ScanSite[]
  asteroids: Record<string, AsteroidState>
  ships: Record<string, ShipState>
  stations: Record<string, StationState>
  research: ResearchState
}

export interface SimEvent {
  id: string
  tick: number
  event: Record<string, unknown>
}

export type StreamMessage = SimEvent[] | { heartbeat: true; tick: number }
```

**Step 4: Create `ui_web/src/api.ts`**

```ts
import type { MetaInfo, SimSnapshot } from './types'

export async function fetchSnapshot(): Promise<SimSnapshot> {
  const response = await fetch('/api/v1/snapshot')
  if (!response.ok) throw new Error(`Snapshot fetch failed: ${response.status}`)
  return response.json()
}

export async function fetchMeta(): Promise<MetaInfo> {
  const response = await fetch('/api/v1/meta')
  if (!response.ok) throw new Error(`Meta fetch failed: ${response.status}`)
  return response.json()
}

export function createEventSource(): EventSource {
  return new EventSource('/api/v1/stream')
}
```

**Step 5: Run tests until all pass**

```bash
cd ui_web && npm test
```

Expected: 3 tests pass.

**Step 6: Commit**

```bash
cd .. && git add ui_web/src/types.ts ui_web/src/api.ts ui_web/src/api.test.ts
git commit -m "feat: add TypeScript types and API functions"
```

---

## Task 8: useSimStream hook

**Files:**
- Create: `ui_web/src/hooks/useSimStream.ts`
- Create: `ui_web/src/hooks/useSimStream.test.ts`

**Step 1: Write failing tests**

Create `ui_web/src/hooks/useSimStream.test.ts`:

```ts
import { act, renderHook } from '@testing-library/react'
import { beforeEach, describe, expect, it, vi } from 'vitest'
import * as api from '../api'
import type { SimSnapshot } from '../types'
import { useSimStream } from './useSimStream'

const baseSnapshot: SimSnapshot = {
  meta: { tick: 5, seed: 42, content_version: '0.0.1' },
  scan_sites: [],
  asteroids: {},
  ships: {},
  stations: {},
  research: { unlocked: [], data_pool: {}, evidence: {} },
}

class MockEventSource {
  onopen: ((e: Event) => void) | null = null
  onerror: ((e: Event) => void) | null = null
  onmessage: ((e: MessageEvent) => void) | null = null
  close = vi.fn()
}

describe('useSimStream', () => {
  beforeEach(() => {
    vi.spyOn(api, 'fetchSnapshot').mockResolvedValue(baseSnapshot)
    vi.spyOn(api, 'createEventSource').mockReturnValue(new MockEventSource() as unknown as EventSource)
  })

  it('fetches snapshot on mount and sets tick', async () => {
    const { result } = renderHook(() => useSimStream())
    await act(async () => { await Promise.resolve() })
    expect(api.fetchSnapshot).toHaveBeenCalledOnce()
    expect(result.current.currentTick).toBe(5)
  })

  it('starts with empty events list', () => {
    const { result } = renderHook(() => useSimStream())
    expect(result.current.events).toEqual([])
  })

  it('closes EventSource on unmount', () => {
    const mockEs = new MockEventSource()
    vi.spyOn(api, 'createEventSource').mockReturnValue(mockEs as unknown as EventSource)
    const { unmount } = renderHook(() => useSimStream())
    unmount()
    expect(mockEs.close).toHaveBeenCalledOnce()
  })
})
```

**Step 2: Run tests — expect "Cannot find module './useSimStream'"**

```bash
cd ui_web && npm test
```

**Step 3: Create `ui_web/src/hooks/useSimStream.ts`**

```ts
import { useEffect, useReducer } from 'react'
import { createEventSource, fetchSnapshot } from '../api'
import type { AsteroidState, ResearchState, SimEvent, SimSnapshot } from '../types'

interface State {
  snapshot: SimSnapshot | null
  events: SimEvent[]
  connected: boolean
  currentTick: number
}

type Action =
  | { type: 'SNAPSHOT_LOADED'; snapshot: SimSnapshot }
  | { type: 'EVENTS_RECEIVED'; events: SimEvent[] }
  | { type: 'HEARTBEAT'; tick: number }
  | { type: 'CONNECTED' }
  | { type: 'DISCONNECTED' }

function applyEvents(
  asteroids: Record<string, AsteroidState>,
  research: ResearchState,
  events: SimEvent[],
): { asteroids: Record<string, AsteroidState>; research: ResearchState } {
  let updatedAsteroids = { ...asteroids }
  let updatedResearch = research

  for (const evt of events) {
    const e = evt.event

    if (e['CompositionMapped']) {
      const { asteroid_id, composition } = e['CompositionMapped'] as { asteroid_id: string; composition: Record<string, number> }
      if (updatedAsteroids[asteroid_id]) {
        updatedAsteroids = {
          ...updatedAsteroids,
          [asteroid_id]: {
            ...updatedAsteroids[asteroid_id],
            knowledge: { ...updatedAsteroids[asteroid_id].knowledge, composition },
          },
        }
      }
    }

    if (e['ScanResult']) {
      const { asteroid_id, tags } = e['ScanResult'] as { asteroid_id: string; tags: [string, number][] }
      if (updatedAsteroids[asteroid_id]) {
        updatedAsteroids = {
          ...updatedAsteroids,
          [asteroid_id]: {
            ...updatedAsteroids[asteroid_id],
            knowledge: { ...updatedAsteroids[asteroid_id].knowledge, tag_beliefs: tags },
          },
        }
      }
    }

    if (e['TechUnlocked']) {
      const { tech_id } = e['TechUnlocked'] as { tech_id: string }
      updatedResearch = {
        ...updatedResearch,
        unlocked: [...updatedResearch.unlocked, tech_id],
      }
    }
  }

  return { asteroids: updatedAsteroids, research: updatedResearch }
}

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'SNAPSHOT_LOADED':
      return { ...state, snapshot: action.snapshot, currentTick: action.snapshot.meta.tick }

    case 'EVENTS_RECEIVED': {
      const newEvents = [...action.events, ...state.events].slice(0, 500)
      if (!state.snapshot) return { ...state, events: newEvents }
      const { asteroids, research } = applyEvents(
        state.snapshot.asteroids,
        state.snapshot.research,
        action.events,
      )
      return {
        ...state,
        events: newEvents,
        snapshot: { ...state.snapshot, asteroids, research },
      }
    }

    case 'HEARTBEAT':
      return { ...state, currentTick: action.tick }

    case 'CONNECTED':
      return { ...state, connected: true }

    case 'DISCONNECTED':
      return { ...state, connected: false }

    default:
      return state
  }
}

const initialState: State = {
  snapshot: null,
  events: [],
  connected: false,
  currentTick: 0,
}

export function useSimStream() {
  const [state, dispatch] = useReducer(reducer, initialState)

  useEffect(() => {
    fetchSnapshot().then((snapshot) => dispatch({ type: 'SNAPSHOT_LOADED', snapshot }))

    const es = createEventSource()
    es.onopen = () => dispatch({ type: 'CONNECTED' })
    es.onerror = () => dispatch({ type: 'DISCONNECTED' })
    es.onmessage = (event: MessageEvent) => {
      const data = JSON.parse(event.data as string) as unknown
      if (data && typeof data === 'object' && 'heartbeat' in data) {
        dispatch({ type: 'HEARTBEAT', tick: (data as { tick: number }).tick })
      } else if (Array.isArray(data)) {
        dispatch({ type: 'EVENTS_RECEIVED', events: data as SimEvent[] })
      }
    }

    return () => { es.close() }
  }, [])

  return { snapshot: state.snapshot, events: state.events, connected: state.connected, currentTick: state.currentTick }
}
```

**Step 4: Run tests until all pass**

```bash
cd ui_web && npm test
```

Expected: 3 tests pass.

**Step 5: Commit**

```bash
cd .. && git add ui_web/src/hooks/
git commit -m "feat: add useSimStream hook"
```

---

## Task 9: StatusBar component

**Files:**
- Create: `ui_web/src/components/StatusBar.tsx`
- Create: `ui_web/src/components/StatusBar.test.tsx`

**Step 1: Write failing tests**

Create `ui_web/src/components/StatusBar.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { describe, expect, it } from 'vitest'
import { StatusBar } from './StatusBar'

describe('StatusBar', () => {
  it('renders tick number', () => {
    render(<StatusBar tick={1440} connected={true} />)
    expect(screen.getByText(/1440/)).toBeInTheDocument()
  })

  it('shows day and hour derived from tick', () => {
    render(<StatusBar tick={1440} connected={true} />)
    expect(screen.getByText(/day 1/i)).toBeInTheDocument()
  })

  it('shows connected when connected', () => {
    render(<StatusBar tick={0} connected={true} />)
    expect(screen.getByText(/connected/i)).toBeInTheDocument()
  })

  it('shows disconnected when not connected', () => {
    render(<StatusBar tick={0} connected={false} />)
    expect(screen.getByText(/disconnected/i)).toBeInTheDocument()
  })
})
```

**Step 2: Run tests — expect failure**

```bash
cd ui_web && npm test
```

**Step 3: Create `ui_web/src/components/StatusBar.tsx`**

```tsx
interface Props {
  tick: number
  connected: boolean
}

export function StatusBar({ tick, connected }: Props) {
  const day = Math.floor(tick / 1440)
  const hour = Math.floor((tick % 1440) / 60)
  const minute = tick % 60

  return (
    <div className="status-bar">
      <span className="status-tick">tick {tick}</span>
      <span className="status-time">
        day {day} | {String(hour).padStart(2, '0')}:{String(minute).padStart(2, '0')}
      </span>
      <span className={`status-connection ${connected ? 'connected' : 'disconnected'}`}>
        {connected ? '● connected' : '○ disconnected'}
      </span>
    </div>
  )
}
```

**Step 4: Run tests until all pass**

```bash
cd ui_web && npm test
```

**Step 5: Commit**

```bash
cd .. && git add ui_web/src/components/StatusBar.tsx ui_web/src/components/StatusBar.test.tsx
git commit -m "feat: add StatusBar component"
```

---

## Task 10: EventsFeed component

**Files:**
- Create: `ui_web/src/components/EventsFeed.tsx`
- Create: `ui_web/src/components/EventsFeed.test.tsx`

**Step 1: Write failing tests**

```tsx
// ui_web/src/components/EventsFeed.test.tsx
import { render, screen } from '@testing-library/react'
import { describe, expect, it } from 'vitest'
import { EventsFeed } from './EventsFeed'
import type { SimEvent } from '../types'

const events: SimEvent[] = [
  { id: 'evt_000001', tick: 10, event: { TechUnlocked: { tech_id: 'tech_deep_scan_v1' } } },
  { id: 'evt_000002', tick: 5, event: { AsteroidDiscovered: { asteroid_id: 'asteroid_0001' } } },
]

describe('EventsFeed', () => {
  it('renders event IDs', () => {
    render(<EventsFeed events={events} />)
    expect(screen.getByText(/evt_000001/)).toBeInTheDocument()
  })

  it('renders event type name', () => {
    render(<EventsFeed events={events} />)
    expect(screen.getByText(/TechUnlocked/)).toBeInTheDocument()
  })

  it('shows empty state with no events', () => {
    render(<EventsFeed events={[]} />)
    expect(screen.getByText(/no events/i)).toBeInTheDocument()
  })
})
```

**Step 2: Run tests — expect failure**

```bash
cd ui_web && npm test
```

**Step 3: Create `ui_web/src/components/EventsFeed.tsx`**

```tsx
import type { SimEvent } from '../types'

interface Props {
  events: SimEvent[]
}

function eventType(event: Record<string, unknown>): string {
  return Object.keys(event)[0] ?? 'Unknown'
}

function eventDetail(event: Record<string, unknown>): string {
  const key = Object.keys(event)[0]
  if (!key) return ''
  const value = event[key] as Record<string, unknown>
  if (!value || typeof value !== 'object') return ''
  return Object.entries(value)
    .map(([k, v]) => `${k}=${String(v)}`)
    .join(' ')
}

export function EventsFeed({ events }: Props) {
  if (events.length === 0) {
    return (
      <div className="events-feed">
        <div className="events-empty">no events yet</div>
      </div>
    )
  }

  return (
    <div className="events-feed">
      {events.map((evt) => (
        <div key={evt.id} className="event-row">
          <span className="event-id">{evt.id}</span>
          <span className="event-tick">t={evt.tick}</span>
          <span className="event-type">{eventType(evt.event)}</span>
          <span className="event-detail">{eventDetail(evt.event)}</span>
        </div>
      ))}
    </div>
  )
}
```

**Step 4: Run tests until all pass**

```bash
cd ui_web && npm test
```

**Step 5: Commit**

```bash
cd .. && git add ui_web/src/components/EventsFeed.tsx ui_web/src/components/EventsFeed.test.tsx
git commit -m "feat: add EventsFeed component"
```

---

## Task 11: AsteroidTable component

**Files:**
- Create: `ui_web/src/components/AsteroidTable.tsx`
- Create: `ui_web/src/components/AsteroidTable.test.tsx`

**Step 1: Write failing tests**

```tsx
// ui_web/src/components/AsteroidTable.test.tsx
import { render, screen } from '@testing-library/react'
import { describe, expect, it } from 'vitest'
import { AsteroidTable } from './AsteroidTable'
import type { AsteroidState } from '../types'

const asteroids: Record<string, AsteroidState> = {
  'asteroid_0001': {
    id: 'asteroid_0001',
    location_node: 'node_belt_inner',
    anomaly_tags: ['IronRich'],
    knowledge: {
      tag_beliefs: [['IronRich', 0.85]],
      composition: { Fe: 0.65, Si: 0.20, He: 0.15 },
    },
  },
}

describe('AsteroidTable', () => {
  it('renders asteroid ID', () => {
    render(<AsteroidTable asteroids={asteroids} />)
    expect(screen.getByText('asteroid_0001')).toBeInTheDocument()
  })

  it('renders tag with confidence', () => {
    render(<AsteroidTable asteroids={asteroids} />)
    expect(screen.getByText(/IronRich/)).toBeInTheDocument()
  })

  it('renders Fe composition percentage', () => {
    render(<AsteroidTable asteroids={asteroids} />)
    expect(screen.getByText(/65%/)).toBeInTheDocument()
  })

  it('shows empty state when no asteroids', () => {
    render(<AsteroidTable asteroids={{}} />)
    expect(screen.getByText(/no asteroids/i)).toBeInTheDocument()
  })
})
```

**Step 2: Run tests — expect failure**

```bash
cd ui_web && npm test
```

**Step 3: Create `ui_web/src/components/AsteroidTable.tsx`**

```tsx
import type { AsteroidState } from '../types'

interface Props {
  asteroids: Record<string, AsteroidState>
}

function pct(value: number): string {
  return `${Math.round(value * 100)}%`
}

function compositionSummary(composition: Record<string, number> | null): string {
  if (!composition) return '—'
  return Object.entries(composition)
    .sort(([, a], [, b]) => b - a)
    .map(([el, frac]) => `${el} ${pct(frac)}`)
    .join(' | ')
}

function tagSummary(tagBeliefs: [string, number][]): string {
  if (tagBeliefs.length === 0) return '—'
  return tagBeliefs.map(([tag, conf]) => `${tag} (${pct(conf)})`).join(', ')
}

export function AsteroidTable({ asteroids }: Props) {
  const rows = Object.values(asteroids)

  if (rows.length === 0) {
    return (
      <div className="asteroid-table">
        <div className="table-empty">no asteroids discovered</div>
      </div>
    )
  }

  return (
    <div className="asteroid-table">
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Node</th>
            <th>Tags</th>
            <th>Composition</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((asteroid) => (
            <tr key={asteroid.id}>
              <td>{asteroid.id}</td>
              <td>{asteroid.location_node}</td>
              <td>{tagSummary(asteroid.knowledge.tag_beliefs)}</td>
              <td>{compositionSummary(asteroid.knowledge.composition)}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}
```

**Step 4: Run tests until all pass**

```bash
cd ui_web && npm test
```

**Step 5: Commit**

```bash
cd .. && git add ui_web/src/components/AsteroidTable.tsx ui_web/src/components/AsteroidTable.test.tsx
git commit -m "feat: add AsteroidTable component"
```

---

## Task 12: ResearchPanel component

**Files:**
- Create: `ui_web/src/components/ResearchPanel.tsx`
- Create: `ui_web/src/components/ResearchPanel.test.tsx`

**Step 1: Write failing tests**

```tsx
// ui_web/src/components/ResearchPanel.test.tsx
import { render, screen } from '@testing-library/react'
import { describe, expect, it } from 'vitest'
import { ResearchPanel } from './ResearchPanel'
import type { ResearchState } from '../types'

const research: ResearchState = {
  unlocked: [],
  data_pool: { ScanData: 42.5 },
  evidence: { tech_deep_scan_v1: 120.0 },
}

const researchUnlocked: ResearchState = {
  unlocked: ['tech_deep_scan_v1'],
  data_pool: { ScanData: 200.0 },
  evidence: { tech_deep_scan_v1: 300.0 },
}

describe('ResearchPanel', () => {
  it('renders tech ID', () => {
    render(<ResearchPanel research={research} />)
    expect(screen.getByText(/tech_deep_scan_v1/)).toBeInTheDocument()
  })

  it('renders evidence value', () => {
    render(<ResearchPanel research={research} />)
    expect(screen.getByText(/120/)).toBeInTheDocument()
  })

  it('shows unlocked label when tech is unlocked', () => {
    render(<ResearchPanel research={researchUnlocked} />)
    expect(screen.getByText(/unlocked/i)).toBeInTheDocument()
  })

  it('shows data pool amount', () => {
    render(<ResearchPanel research={research} />)
    expect(screen.getByText(/42/)).toBeInTheDocument()
  })
})
```

**Step 2: Run tests — expect failure**

```bash
cd ui_web && npm test
```

**Step 3: Create `ui_web/src/components/ResearchPanel.tsx`**

```tsx
import type { ResearchState } from '../types'

interface Props {
  research: ResearchState
}

function unlockProbability(evidence: number, difficulty = 200): number {
  return 1 - Math.exp(-evidence / difficulty)
}

export function ResearchPanel({ research }: Props) {
  const allTechIds = new Set([...research.unlocked, ...Object.keys(research.evidence)])

  return (
    <div className="research-panel">
      <div className="data-pool">
        <span className="label">Data pool: </span>
        {Object.entries(research.data_pool).map(([kind, amount]) => (
          <span key={kind} className="data-item">
            {kind}: {amount.toFixed(1)}
          </span>
        ))}
        {Object.keys(research.data_pool).length === 0 && (
          <span className="data-item empty">—</span>
        )}
      </div>
      <div className="tech-list">
        {[...allTechIds].map((techId) => {
          const evidence = research.evidence[techId] ?? 0
          const isUnlocked = research.unlocked.includes(techId)
          const prob = unlockProbability(evidence)
          return (
            <div key={techId} className={`tech-row ${isUnlocked ? 'tech-unlocked' : ''}`}>
              <div className="tech-id">{techId}</div>
              <div className="tech-evidence">evidence: {evidence.toFixed(1)}</div>
              {isUnlocked ? (
                <div className="tech-status unlocked">✓ unlocked</div>
              ) : (
                <div className="tech-status">p(unlock): {(prob * 100).toFixed(1)}%</div>
              )}
            </div>
          )
        })}
        {allTechIds.size === 0 && <div className="tech-empty">no research data yet</div>}
      </div>
    </div>
  )
}
```

**Step 4: Run tests until all pass**

```bash
cd ui_web && npm test
```

**Step 5: Commit**

```bash
cd .. && git add ui_web/src/components/ResearchPanel.tsx ui_web/src/components/ResearchPanel.test.tsx
git commit -m "feat: add ResearchPanel component"
```

---

## Task 13: App.tsx + CSS

**Files:**
- Modify: `ui_web/src/App.tsx`
- Modify: `ui_web/src/App.css`
- Modify: `ui_web/src/index.css`

**Step 1: Write App smoke test**

Create `ui_web/src/App.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { beforeEach, describe, expect, it, vi } from 'vitest'
import App from './App'
import * as api from './api'
import type { SimSnapshot } from './types'

const snapshot: SimSnapshot = {
  meta: { tick: 0, seed: 42, content_version: '0.0.1' },
  scan_sites: [],
  asteroids: {},
  ships: {},
  stations: {},
  research: { unlocked: [], data_pool: {}, evidence: {} },
}

beforeEach(() => {
  vi.spyOn(api, 'fetchSnapshot').mockResolvedValue(snapshot)
  vi.spyOn(api, 'createEventSource').mockReturnValue({
    onopen: null,
    onerror: null,
    onmessage: null,
    close: vi.fn(),
  } as unknown as EventSource)
})

describe('App', () => {
  it('renders without crashing', () => {
    render(<App />)
    expect(document.body).toBeInTheDocument()
  })

  it('renders status bar with tick', () => {
    render(<App />)
    expect(screen.getByText(/tick/i)).toBeInTheDocument()
  })

  it('renders all three panel headings', () => {
    render(<App />)
    expect(screen.getByText(/events/i)).toBeInTheDocument()
    expect(screen.getByText(/asteroids/i)).toBeInTheDocument()
    expect(screen.getByText(/research/i)).toBeInTheDocument()
  })
})
```

**Step 2: Run tests — expect failure**

```bash
cd ui_web && npm test
```

**Step 3: Replace `ui_web/src/App.tsx`**

```tsx
import './App.css'
import { AsteroidTable } from './components/AsteroidTable'
import { EventsFeed } from './components/EventsFeed'
import { ResearchPanel } from './components/ResearchPanel'
import { StatusBar } from './components/StatusBar'
import { useSimStream } from './hooks/useSimStream'

export default function App() {
  const { snapshot, events, connected, currentTick } = useSimStream()

  return (
    <div className="app">
      <StatusBar tick={currentTick} connected={connected} />
      <div className="panels">
        <section className="panel panel-events">
          <h2>Events</h2>
          <EventsFeed events={events} />
        </section>
        <section className="panel panel-asteroids">
          <h2>Asteroids</h2>
          <AsteroidTable asteroids={snapshot?.asteroids ?? {}} />
        </section>
        <section className="panel panel-research">
          <h2>Research</h2>
          {snapshot && <ResearchPanel research={snapshot.research} />}
        </section>
      </div>
    </div>
  )
}
```

**Step 4: Replace `ui_web/src/App.css`**

```css
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background: #0a0e1a;
  color: #c8d8f0;
  font-family: 'Courier New', Courier, monospace;
  font-size: 13px;
}

.app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

/* Status bar */
.status-bar {
  display: flex;
  gap: 24px;
  align-items: center;
  padding: 6px 16px;
  background: #0d1226;
  border-bottom: 1px solid #1e2d50;
  font-size: 12px;
  flex-shrink: 0;
}
.status-tick { color: #a8c4e8; font-weight: bold; }
.status-time { color: #7a9cc8; }
.status-connection.connected { color: #4caf7d; }
.status-connection.disconnected { color: #e05555; }

/* Three-panel layout */
.panels {
  display: flex;
  flex: 1;
  overflow: hidden;
  gap: 1px;
  background: #1e2d50;
}

.panel {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: #0a0e1a;
  padding: 12px;
}

.panel h2 {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #4a6a9a;
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid #1e2d50;
  flex-shrink: 0;
}

.panel-events { flex: 1; min-width: 220px; }
.panel-asteroids { flex: 2; }
.panel-research { flex: 1; min-width: 220px; }

/* Events feed */
.events-feed { overflow-y: auto; flex: 1; }
.events-empty { color: #3a5070; font-style: italic; }
.event-row {
  display: flex;
  gap: 6px;
  padding: 2px 0;
  border-bottom: 1px solid #0d1226;
  font-size: 11px;
  overflow: hidden;
}
.event-id { color: #3a6090; min-width: 90px; flex-shrink: 0; }
.event-tick { color: #2a4060; min-width: 44px; flex-shrink: 0; }
.event-type { color: #70a0d0; min-width: 120px; flex-shrink: 0; }
.event-detail { color: #607090; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* Asteroid table */
.asteroid-table { overflow-y: auto; flex: 1; }
.table-empty { color: #3a5070; font-style: italic; }
.asteroid-table table { width: 100%; border-collapse: collapse; font-size: 11px; }
.asteroid-table th {
  text-align: left;
  color: #4a6a9a;
  padding: 4px 8px;
  border-bottom: 1px solid #1e2d50;
  font-weight: normal;
}
.asteroid-table td { padding: 3px 8px; border-bottom: 1px solid #0d1226; }

/* Research panel */
.research-panel { overflow-y: auto; flex: 1; }
.data-pool {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 10px;
  font-size: 11px;
  color: #7a9cc8;
}
.data-pool .label { color: #4a6a9a; }
.data-item.empty { color: #3a5070; }
.tech-row { padding: 6px 0; border-bottom: 1px solid #0d1226; font-size: 11px; }
.tech-id { color: #70a0d0; margin-bottom: 2px; }
.tech-evidence { color: #506080; }
.tech-status { color: #506080; margin-top: 2px; }
.tech-status.unlocked { color: #4caf7d; }
.tech-empty { color: #3a5070; font-style: italic; }
```

**Step 5: Replace `ui_web/src/index.css`** with empty file (reset is handled in App.css):

```css
/* Reset handled in App.css */
```

**Step 6: Run all tests until they pass**

```bash
cd ui_web && npm test
```

Expected: all tests pass including the 3 new App tests.

**Step 7: Commit**

```bash
cd .. && git add ui_web/src/App.tsx ui_web/src/App.css ui_web/src/App.test.tsx ui_web/src/index.css
git commit -m "feat: wire up App.tsx with three-panel mission control layout and CSS"
```

---

## Task 14: End-to-end verification

**Step 1: Run all Rust tests**

```bash
cargo test
```

Expected: all existing tests + 4 new sim_daemon tests pass.

**Step 2: Run all React tests**

```bash
cd ui_web && npm test
```

Expected: all tests pass.

**Step 3: Start sim_daemon**

```bash
cargo run -p sim_daemon -- run --seed 42 --ticks-per-sec 10
```

Expected: "sim_daemon listening on http://localhost:3001  speed=10 ticks/sec"

**Step 4: Verify endpoints**

In a second terminal:
```bash
curl http://localhost:3001/api/v1/meta
# Expected: {"tick":N,"seed":42,"content_version":"0.0.1"}

curl http://localhost:3001/api/v1/snapshot | python3 -m json.tool | head -20
# Expected: valid JSON with meta, asteroids, ships, stations, research keys

curl -N --no-buffer http://localhost:3001/api/v1/stream
# Expected: data: [...] lines, heartbeat every 5s. Ctrl-C to stop.
```

**Step 5: Start React dev server**

In a third terminal:
```bash
cd ui_web && npm run dev
```

**Step 6: Open http://localhost:5173 in browser**

Verify:
- Status bar shows tick number incrementing in real-time
- Events feed populates (TaskStarted, AsteroidDiscovered, etc.)
- Asteroid table shows rows as asteroids are discovered
- Research panel shows evidence accumulating; eventually shows "✓ unlocked"
- No CORS errors in browser console (F12 → Console)

**Step 7: Final commit**

```bash
git add -A
git commit -m "feat: complete MVP-1 — sim_daemon HTTP server + React mission control UI"
```

---

## Notes

- `true_composition` is included in `/api/v1/snapshot` — this is fine for single-player MVP-1; filter it server-side in a future milestone if needed.
- `AnomalyTag` and `DataKind` serialize as strings by default (`"IronRich"`, `"ScanData"`), so TypeScript `string` types are correct.
- HashMap keys like `AsteroidId(String)` serialize as bare strings in serde_json (newtype transparent behavior). TypeScript `Record<string, ...>` is correct.
- If `futures_core` isn't found in sim_daemon, add `futures-core = "0.3"` to `crates/sim_daemon/Cargo.toml`.
