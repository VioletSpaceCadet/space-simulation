# Mining Feature Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:subagent-driven-development to implement this plan task-by-task.

**Goal:** Add autonomous asteroid mining: ships mine ore, haul it to a station, and deposit it in the station's inventory.

**Architecture:** Cargo is tracked as kg-per-element with a volume (m³) capacity constraint. Volume used = Σ(cargo[element] / density[element]). Mining duration is pre-computed and embedded in the task (like Transit's `total_ticks`). The autopilot gains a third looping phase after survey/deep-scan: mine → transit to station → deposit → repeat.

**Tech Stack:** Rust (sim_core, sim_control, sim_daemon), React + Tailwind CSS (ui_web), react-resizable-panels (new dep for Task 7).

---

## How to run tests

```bash
# Rust (from repo root)
~/.cargo/bin/cargo test

# React (from ui_web/)
npm test -- --run
```

---

## Task 1: Asteroid mass field

**Files:**
- Modify: `crates/sim_core/src/types.rs`
- Modify: `crates/sim_core/src/tasks.rs`
- Modify: `crates/sim_core/src/lib.rs` (test helpers)
- Modify: `crates/sim_daemon/src/main.rs` (test helper)
- Modify: `content/constants.json`

### Step 1: Write the failing tests

In `crates/sim_core/src/lib.rs`, add to the `#[cfg(test)]` module:

```rust
#[test]
fn test_asteroid_has_mass_after_survey() {
    let content = test_content();
    let mut state = test_state(&content);
    let mut rng = make_rng();

    let cmd = survey_command(&state);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);

    let asteroid = state.asteroids.values().next().unwrap();
    assert!(asteroid.mass_kg > 0.0, "asteroid must have positive mass after survey");
}

#[test]
fn test_asteroid_mass_within_range() {
    let content = test_content();
    let mut state = test_state(&content);
    let mut rng = make_rng();

    let cmd = survey_command(&state);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);

    let asteroid = state.asteroids.values().next().unwrap();
    // test_content sets min=max=500.0 for determinism
    assert!(
        (asteroid.mass_kg - 500.0).abs() < 1e-3,
        "mass should be 500.0 in test content (fixed range)"
    );
}
```

**Step 2: Run to confirm they fail**

```bash
~/.cargo/bin/cargo test test_asteroid_has_mass 2>&1 | tail -5
```

Expected: compile error — `mass_kg` field does not exist.

### Step 3: Add `mass_kg` to `AsteroidState` and new constants

In `crates/sim_core/src/types.rs`:

```rust
// In AsteroidState, add after anomaly_tags:
pub mass_kg: f32,
```

```rust
// In Constants, add after asteroid_count_per_template:
pub asteroid_mass_min_kg: f32,
pub asteroid_mass_max_kg: f32,
```

### Step 4: Assign mass in `resolve_survey`

In `crates/sim_core/src/tasks.rs`, in `resolve_survey`, after rolling composition and before inserting the asteroid:

```rust
let mass_kg = rng.gen_range(
    content.constants.asteroid_mass_min_kg..=content.constants.asteroid_mass_max_kg,
);
```

Then add `mass_kg` to the `AsteroidState` struct literal:

```rust
state.asteroids.insert(
    asteroid_id.clone(),
    AsteroidState {
        id: asteroid_id.clone(),
        location_node: site.node.clone(),
        true_composition: composition,
        anomaly_tags: anomaly_tags.clone(),
        mass_kg,   // <-- add this line
        knowledge: AsteroidKnowledge {
            tag_beliefs: vec![],
            composition: None,
        },
    },
);
```

### Step 5: Update test helpers

In `crates/sim_core/src/lib.rs`, update `test_content()` Constants block — add:

```rust
asteroid_mass_min_kg: 500.0,   // fixed range so tests are deterministic
asteroid_mass_max_kg: 500.0,
```

In `crates/sim_daemon/src/main.rs`, update `make_test_state()` Constants block — add:

```rust
asteroid_mass_min_kg: 500.0,
asteroid_mass_max_kg: 500.0,
```

### Step 6: Update `content/constants.json`

Add after `asteroid_count_per_template`:

```json
"asteroid_mass_min_kg": 100.0,
"asteroid_mass_max_kg": 100000.0,
```

### Step 7: Run tests

```bash
~/.cargo/bin/cargo test 2>&1 | tail -10
```

Expected: all tests pass including the two new ones.

### Step 8: Commit

```bash
git add crates/sim_core/src/types.rs crates/sim_core/src/tasks.rs \
        crates/sim_core/src/lib.rs crates/sim_daemon/src/main.rs \
        content/constants.json
git commit -m "feat(sim): add asteroid mass_kg field, assigned at survey time"
```

---

## Task 2: Element definitions

**Files:**
- Create: `content/elements.json`
- Modify: `crates/sim_core/src/types.rs`
- Modify: `crates/sim_daemon/src/world.rs`
- Modify: `crates/sim_core/src/lib.rs` (test helpers)
- Modify: `crates/sim_daemon/src/main.rs` (test helper)

### Step 1: Write the failing test

In `crates/sim_core/src/lib.rs`, add to the test module:

```rust
#[test]
fn test_content_has_element_densities() {
    let content = test_content();
    let fe = content.elements.iter().find(|e| e.id == "Fe")
        .expect("Fe element must be defined in content");
    assert!((fe.density_kg_per_m3 - 7874.0).abs() < 1.0, "Fe density should be ~7874 kg/m³");
}
```

**Step 2: Run to confirm it fails**

```bash
~/.cargo/bin/cargo test test_content_has_element_densities 2>&1 | tail -5
```

Expected: compile error — `elements` field does not exist on `GameContent`.

### Step 3: Add `ElementDef` struct and `elements` to `GameContent`

In `crates/sim_core/src/types.rs`, add a new struct after `AsteroidTemplateDef`:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ElementDef {
    pub id: String,
    pub density_kg_per_m3: f32,
    pub display_name: String,
}
```

Add `elements` field to `GameContent`:

```rust
pub struct GameContent {
    pub content_version: String,
    pub techs: Vec<TechDef>,
    pub solar_system: SolarSystemDef,
    pub asteroid_templates: Vec<AsteroidTemplateDef>,
    pub elements: Vec<ElementDef>,   // <-- add this
    pub constants: Constants,
}
```

### Step 4: Create `content/elements.json`

```json
{
  "elements": [
    { "id": "Fe", "density_kg_per_m3": 7874.0, "display_name": "Iron" },
    { "id": "Si", "density_kg_per_m3": 2329.0, "display_name": "Silicon" },
    { "id": "He", "density_kg_per_m3": 0.164,  "display_name": "Helium" }
  ]
}
```

### Step 5: Load elements in `world.rs`

In `crates/sim_daemon/src/world.rs`:

Add a new file struct after `AsteroidTemplatesFile`:

```rust
#[derive(Deserialize)]
struct ElementsFile {
    elements: Vec<ElementDef>,
}
```

Add to imports: `ElementDef` (it's already re-exported via `sim_core::*`).

In `load_content`, add loading after templates:

```rust
let elements_file: ElementsFile = serde_json::from_str(
    &std::fs::read_to_string(dir.join("elements.json")).context("reading elements.json")?,
)
.context("parsing elements.json")?;
```

Add to `GameContent` construction:

```rust
Ok(GameContent {
    content_version: techs_file.content_version,
    techs: techs_file.techs,
    solar_system,
    asteroid_templates: templates_file.templates,
    elements: elements_file.elements,   // <-- add this
    constants,
})
```

### Step 6: Update test helpers

In `crates/sim_core/src/lib.rs`, update `test_content()` — add `elements` field:

```rust
elements: vec![
    ElementDef { id: "Fe".to_string(), density_kg_per_m3: 7874.0, display_name: "Iron".to_string() },
    ElementDef { id: "Si".to_string(), density_kg_per_m3: 2329.0, display_name: "Silicon".to_string() },
],
```

In `crates/sim_daemon/src/main.rs`, update `make_test_state()` `GameContent` — add `elements` field:

```rust
elements: vec![
    sim_core::ElementDef { id: "Fe".to_string(), density_kg_per_m3: 7874.0, display_name: "Iron".to_string() },
    sim_core::ElementDef { id: "Si".to_string(), density_kg_per_m3: 2329.0, display_name: "Silicon".to_string() },
],
```

Also add `ElementDef` to the `use sim_core::{...}` import at the top of `main.rs`.

### Step 7: Run tests

```bash
~/.cargo/bin/cargo test 2>&1 | tail -10
```

Expected: all tests pass including `test_content_has_element_densities`.

### Step 8: Commit

```bash
git add content/elements.json crates/sim_core/src/types.rs \
        crates/sim_daemon/src/world.rs crates/sim_core/src/lib.rs \
        crates/sim_daemon/src/main.rs
git commit -m "feat(sim): add ElementDef and elements.json with density data"
```

---

## Task 3: Ship and station cargo holds

**Files:**
- Modify: `crates/sim_core/src/types.rs`
- Modify: `crates/sim_daemon/src/world.rs`
- Modify: `crates/sim_core/src/lib.rs` (test helpers)
- Modify: `crates/sim_daemon/src/main.rs` (test helper)
- Modify: `content/constants.json`

### Step 1: Write the failing tests

In `crates/sim_core/src/lib.rs`, add to the test module:

```rust
#[test]
fn test_ship_starts_with_empty_cargo() {
    let content = test_content();
    let state = test_state(&content);
    let ship = state.ships.values().next().unwrap();
    assert!(ship.cargo.is_empty(), "ship cargo should be empty at start");
    assert!((ship.cargo_capacity_m3 - 20.0).abs() < 1e-5, "ship capacity should be 20 m³");
}

#[test]
fn test_station_starts_with_empty_cargo() {
    let content = test_content();
    let state = test_state(&content);
    let station = state.stations.values().next().unwrap();
    assert!(station.cargo.is_empty(), "station cargo should be empty at start");
    assert!((station.cargo_capacity_m3 - 10_000.0).abs() < 1e-5, "station capacity should be 10,000 m³");
}
```

**Step 2: Run to confirm they fail**

```bash
~/.cargo/bin/cargo test test_ship_starts_with_empty_cargo 2>&1 | tail -5
```

Expected: compile error — `cargo` field does not exist.

### Step 3: Add cargo fields to types

In `crates/sim_core/src/types.rs`:

```rust
// In ShipState, add after owner:
pub cargo: HashMap<ElementId, f32>,
pub cargo_capacity_m3: f32,
```

```rust
// In StationState, add after location_node:
pub cargo: HashMap<ElementId, f32>,
pub cargo_capacity_m3: f32,
```

```rust
// In Constants, add after asteroid_mass_max_kg:
pub ship_cargo_capacity_m3: f32,
pub station_cargo_capacity_m3: f32,
```

### Step 4: Wire up in `world.rs`

In `crates/sim_daemon/src/world.rs`, update `build_initial_state`:

```rust
// In ship construction:
let ship = ShipState {
    id: ship_id.clone(),
    location_node: earth_orbit.clone(),
    owner,
    cargo: std::collections::HashMap::new(),
    cargo_capacity_m3: c.ship_cargo_capacity_m3,
    task: None,
};
```

```rust
// In station construction:
let station = StationState {
    id: station_id.clone(),
    location_node: earth_orbit.clone(),
    power_available_per_tick: c.station_power_available_per_tick,
    cargo: std::collections::HashMap::new(),
    cargo_capacity_m3: c.station_cargo_capacity_m3,
    facilities: FacilitiesState { ... },
};
```

### Step 5: Update all test helpers and inline state

**In `crates/sim_core/src/lib.rs`:**

In `test_content()` Constants, add:
```rust
ship_cargo_capacity_m3: 20.0,
station_cargo_capacity_m3: 10_000.0,
```

In `test_state()`, update `ShipState`:
```rust
ShipState {
    id: ship_id,
    location_node: node_id.clone(),
    owner,
    cargo: HashMap::new(),
    cargo_capacity_m3: 20.0,
    task: None,
},
```

In `test_state()`, update `StationState`:
```rust
StationState {
    id: station_id,
    location_node: node_id,
    power_available_per_tick: 100.0,
    cargo: HashMap::new(),
    cargo_capacity_m3: 10_000.0,
    facilities: FacilitiesState { ... },
},
```

In `transit_moves_ship_and_starts_next_task`, update the inline `ShipState`:
```rust
ShipState {
    id: ship_id.clone(),
    location_node: node_a.clone(),
    owner: owner.clone(),
    cargo: HashMap::new(),
    cargo_capacity_m3: 20.0,
    task: None,
},
```

In the same test, update the inline `StationState`:
```rust
StationState {
    id: station_id,
    location_node: node_a.clone(),
    power_available_per_tick: 100.0,
    cargo: HashMap::new(),
    cargo_capacity_m3: 10_000.0,
    facilities: FacilitiesState { ... },
},
```

**In `crates/sim_daemon/src/main.rs`:**

In `make_test_state()` Constants, add:
```rust
ship_cargo_capacity_m3: 20.0,
station_cargo_capacity_m3: 10_000.0,
```

(The `game_state` is built by `build_initial_state` which now handles cargo, so no further change needed there.)

### Step 6: Update `content/constants.json`

Add after `asteroid_mass_max_kg`:

```json
"ship_cargo_capacity_m3": 20.0,
"station_cargo_capacity_m3": 10000.0,
```

### Step 7: Run tests

```bash
~/.cargo/bin/cargo test 2>&1 | tail -10
```

Expected: all tests pass.

### Step 8: Commit

```bash
git add crates/sim_core/src/types.rs crates/sim_daemon/src/world.rs \
        crates/sim_core/src/lib.rs crates/sim_daemon/src/main.rs \
        content/constants.json
git commit -m "feat(sim): add cargo holds to ships and stations"
```

---

## Task 4: Mine task

**Files:**
- Modify: `crates/sim_core/src/types.rs`
- Modify: `crates/sim_core/src/tasks.rs`
- Modify: `crates/sim_core/src/engine.rs`
- Modify: `crates/sim_core/src/lib.rs` (test helpers + tests)
- Modify: `crates/sim_daemon/src/main.rs` (test helper)
- Modify: `content/constants.json`

### Step 1: Add `TaskKind::Mine` and `Event::OreMined` and new constant

In `crates/sim_core/src/types.rs`:

```rust
// In TaskKind enum, add after DeepScan:
Mine {
    asteroid: AsteroidId,
    /// Pre-computed mining duration (ticks), computed at task assignment.
    duration_ticks: u64,
},
```

```rust
// In Event enum, add after ShipArrived:
OreMined {
    asteroid_id: AsteroidId,
    /// kg extracted per element
    extracted: HashMap<ElementId, f32>,
    asteroid_remaining_kg: f32,
},
```

```rust
// In Constants, add after station_cargo_capacity_m3:
/// kg of raw ore extracted per tick of mining
pub mining_rate_kg_per_tick: f32,
```

### Step 2: Write the failing tests

In `crates/sim_core/src/lib.rs`, add to the test module:

```rust
// Helper: build a state with an already-surveyed asteroid (mass 500, 70% Fe / 30% Si).
fn state_with_asteroid(content: &GameContent) -> (GameState, AsteroidId) {
    let mut state = test_state(content);
    let mut rng = make_rng();
    let cmd = survey_command(&state);
    tick(&mut state, &[cmd], content, &mut rng, EventLevel::Normal);
    tick(&mut state, &[], content, &mut rng, EventLevel::Normal);
    let asteroid_id = state.asteroids.keys().next().unwrap().clone();
    (state, asteroid_id)
}

fn mine_command(state: &GameState, asteroid_id: &AsteroidId, content: &GameContent) -> CommandEnvelope {
    let ship_id = ShipId("ship_0001".to_string());
    let ship = &state.ships[&ship_id];
    let asteroid = &state.asteroids[asteroid_id];
    // Use a simple fixed duration for tests
    let duration_ticks = 10;
    CommandEnvelope {
        id: CommandId("cmd_mine_001".to_string()),
        issued_by: ship.owner.clone(),
        issued_tick: state.meta.tick,
        execute_at_tick: state.meta.tick,
        command: Command::AssignShipTask {
            ship_id,
            task_kind: TaskKind::Mine {
                asteroid: asteroid_id.clone(),
                duration_ticks,
            },
        },
    }
}

#[test]
fn test_mine_emits_ore_mined_event() {
    let content = test_content();
    let (mut state, asteroid_id) = state_with_asteroid(&content);
    let mut rng = make_rng();

    let cmd = mine_command(&state, &asteroid_id, &content);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    // Fast forward to completion (duration_ticks=10, so tick 10+current)
    let completion_tick = state.meta.tick + 10;
    while state.meta.tick < completion_tick {
        tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);
    }
    let events = tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);

    assert!(
        events.iter().any(|e| matches!(e.event, Event::OreMined { .. })),
        "OreMined event should be emitted when mining completes"
    );
}

#[test]
fn test_mine_adds_ore_to_ship_cargo() {
    let content = test_content();
    let (mut state, asteroid_id) = state_with_asteroid(&content);
    let mut rng = make_rng();

    let ship_id = ShipId("ship_0001".to_string());
    assert!(state.ships[&ship_id].cargo.is_empty());

    let cmd = mine_command(&state, &asteroid_id, &content);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    let completion_tick = state.meta.tick + 10;
    while state.meta.tick <= completion_tick {
        tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);
    }

    let cargo = &state.ships[&ship_id].cargo;
    assert!(!cargo.is_empty(), "ship cargo should not be empty after mining");
    assert!(cargo.values().any(|&kg| kg > 0.0), "extracted mass must be positive");
}

#[test]
fn test_mine_reduces_asteroid_mass() {
    let content = test_content();
    let (mut state, asteroid_id) = state_with_asteroid(&content);
    let mut rng = make_rng();

    let original_mass = state.asteroids[&asteroid_id].mass_kg;
    let cmd = mine_command(&state, &asteroid_id, &content);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    let completion_tick = state.meta.tick + 10;
    while state.meta.tick <= completion_tick {
        tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);
    }

    // Asteroid should still exist (500 kg, only mined for 10 ticks at 50 kg/tick = 500 kg... might be depleted)
    // Use a very short duration so it's not fully depleted
    let remaining = state.asteroids.get(&asteroid_id).map(|a| a.mass_kg).unwrap_or(0.0);
    assert!(remaining < original_mass, "asteroid mass must decrease after mining");
}

#[test]
fn test_mine_removes_depleted_asteroid() {
    let mut content = test_content();
    content.constants.mining_rate_kg_per_tick = 1_000_000.0; // deplete in 1 tick
    let (mut state, asteroid_id) = state_with_asteroid(&content);
    let mut rng = make_rng();

    let cmd = mine_command(&state, &asteroid_id, &content);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    // Complete after 1 tick (duration_ticks=10 but mass runs out)
    // Actually we set duration_ticks=10 in mine_command but the asteroid should deplete at resolution
    // Run to completion
    for _ in 0..11 {
        tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);
    }

    assert!(
        !state.asteroids.contains_key(&asteroid_id),
        "fully mined asteroid should be removed from state"
    );
}
```

**Step 3: Run to confirm they fail**

```bash
~/.cargo/bin/cargo test test_mine 2>&1 | tail -5
```

Expected: compile errors — `Mine` variant and `OreMined` event not defined.

### Step 4: Update `task_duration`, `task_kind_label`, `task_target`

In `crates/sim_core/src/tasks.rs`:

```rust
// In task_duration:
TaskKind::Mine { duration_ticks, .. } => *duration_ticks,
```

```rust
// In task_kind_label:
TaskKind::Mine { .. } => "Mine",
```

```rust
// In task_target:
TaskKind::Mine { asteroid, .. } => Some(asteroid.0.clone()),
```

### Step 5: Add `cargo_volume_used` and `mine_duration` helpers

In `crates/sim_core/src/tasks.rs`, add after `composition_noise_sigma`:

```rust
/// Volume (m³) currently occupied by the ship's cargo.
/// Unknown elements default to 1.0 kg/m³ (safe fallback).
pub fn cargo_volume_used(cargo: &HashMap<ElementId, f32>, content: &GameContent) -> f32 {
    cargo
        .iter()
        .map(|(element_id, &mass_kg)| {
            let density = content
                .elements
                .iter()
                .find(|e| &e.id == element_id)
                .map(|e| e.density_kg_per_m3)
                .unwrap_or(1.0);
            mass_kg / density
        })
        .sum()
}

/// Pre-compute how many ticks a mining run will take.
///
/// Stops when the cargo hold fills OR the asteroid is depleted, whichever comes first.
pub fn mine_duration(asteroid: &AsteroidState, ship: &ShipState, content: &GameContent) -> u64 {
    // m³ consumed per kg of bulk ore (weighted by composition fractions).
    let effective_m3_per_kg: f32 = asteroid
        .true_composition
        .iter()
        .map(|(element_id, &fraction)| {
            let density = content
                .elements
                .iter()
                .find(|e| &e.id == element_id)
                .map(|e| e.density_kg_per_m3)
                .unwrap_or(1.0);
            fraction / density
        })
        .sum();

    let volume_used = cargo_volume_used(&ship.cargo, content);
    let free_volume = (ship.cargo_capacity_m3 - volume_used).max(0.0);
    let rate = content.constants.mining_rate_kg_per_tick;

    let ticks_to_fill = if effective_m3_per_kg > 0.0 {
        (free_volume / (rate * effective_m3_per_kg)).ceil() as u64
    } else {
        u64::MAX
    };
    let ticks_to_deplete = (asteroid.mass_kg / rate).ceil() as u64;

    ticks_to_fill.min(ticks_to_deplete).max(1)
}
```

Also add `pub use tasks::{cargo_volume_used, mine_duration};` to `crates/sim_core/src/lib.rs` so sim_control can use them.

### Step 6: Add `resolve_mine`

In `crates/sim_core/src/tasks.rs`, add after `resolve_deep_scan`:

```rust
pub(crate) fn resolve_mine(
    state: &mut GameState,
    ship_id: &ShipId,
    asteroid_id: &AsteroidId,
    content: &GameContent,
    events: &mut Vec<EventEnvelope>,
) {
    let current_tick = state.meta.tick;

    let Some(asteroid) = state.asteroids.get(asteroid_id) else {
        set_ship_idle(state, ship_id, current_tick);
        return; // Asteroid already gone — nothing to do.
    };

    let ship = match state.ships.get(ship_id) {
        Some(s) => s,
        None => return,
    };

    // How much volume is free in the hold?
    let volume_used = cargo_volume_used(&ship.cargo, content);
    let free_volume = (ship.cargo_capacity_m3 - volume_used).max(0.0);

    // Effective m³/kg for this asteroid's mixed composition.
    let effective_m3_per_kg: f32 = asteroid
        .true_composition
        .iter()
        .map(|(element_id, &fraction)| {
            let density = content
                .elements
                .iter()
                .find(|e| &e.id == element_id)
                .map(|e| e.density_kg_per_m3)
                .unwrap_or(1.0);
            fraction / density
        })
        .sum();

    // Total kg we can extract: limited by asteroid mass and cargo space.
    let max_kg_by_volume = if effective_m3_per_kg > 0.0 {
        free_volume / effective_m3_per_kg
    } else {
        f32::MAX
    };
    let extracted_total_kg = asteroid.mass_kg.min(max_kg_by_volume);

    // Distribute extracted mass by composition fractions.
    let true_composition = asteroid.true_composition.clone();
    let extracted: HashMap<ElementId, f32> = true_composition
        .iter()
        .map(|(element_id, &fraction)| (element_id.clone(), extracted_total_kg * fraction))
        .collect();

    // Update asteroid mass; remove if depleted.
    let asteroid_remaining_kg = asteroid.mass_kg - extracted_total_kg;
    if asteroid_remaining_kg <= 0.0 {
        state.asteroids.remove(asteroid_id);
    } else if let Some(asteroid) = state.asteroids.get_mut(asteroid_id) {
        asteroid.mass_kg = asteroid_remaining_kg;
    }

    // Add extracted ore to ship cargo.
    if let Some(ship) = state.ships.get_mut(ship_id) {
        for (element_id, kg) in &extracted {
            *ship.cargo.entry(element_id.clone()).or_insert(0.0) += kg;
        }
    }

    events.push(crate::emit(
        &mut state.counters,
        current_tick,
        Event::OreMined {
            asteroid_id: asteroid_id.clone(),
            extracted: extracted.clone(),
            asteroid_remaining_kg: asteroid_remaining_kg.max(0.0),
        },
    ));

    set_ship_idle(state, ship_id, current_tick);

    events.push(crate::emit(
        &mut state.counters,
        current_tick,
        Event::TaskCompleted {
            ship_id: ship_id.clone(),
            task_kind: "Mine".to_string(),
            target: Some(asteroid_id.0.clone()),
        },
    ));
}
```

### Step 7: Wire up Mine in the engine

In `crates/sim_core/src/engine.rs`:

Add `resolve_mine` to the imports at the top:
```rust
use crate::tasks::{
    deep_scan_enabled, resolve_deep_scan, resolve_mine, resolve_survey, resolve_transit,
    task_duration, task_kind_label, task_target,
};
```

In `resolve_ship_tasks`, add Mine to the match:
```rust
TaskKind::Mine { ref asteroid, .. } => {
    resolve_mine(state, &ship_id, asteroid, content, events);
}
```

No special validation needed in `apply_commands` for Mine (unlike DeepScan which requires a tech unlock).

### Step 8: Update constants

In `content/constants.json`, add:
```json
"mining_rate_kg_per_tick": 50.0,
```

In `crates/sim_core/src/lib.rs` `test_content()` Constants, add:
```rust
mining_rate_kg_per_tick: 50.0,
```

In `crates/sim_daemon/src/main.rs` `make_test_state()` Constants, add:
```rust
mining_rate_kg_per_tick: 50.0,
```

### Step 9: Run tests

```bash
~/.cargo/bin/cargo test 2>&1 | tail -10
```

Expected: all tests pass including the four new mine tests.

### Step 10: Commit

```bash
git add crates/sim_core/src/types.rs crates/sim_core/src/tasks.rs \
        crates/sim_core/src/engine.rs crates/sim_core/src/lib.rs \
        crates/sim_daemon/src/main.rs content/constants.json
git commit -m "feat(sim): add Mine task with ore extraction and asteroid depletion"
```

---

## Task 5: Deposit task

**Files:**
- Modify: `crates/sim_core/src/types.rs`
- Modify: `crates/sim_core/src/tasks.rs`
- Modify: `crates/sim_core/src/engine.rs`
- Modify: `crates/sim_core/src/lib.rs` (test helpers + tests)
- Modify: `crates/sim_daemon/src/main.rs` (test helper)
- Modify: `content/constants.json`

### Step 1: Add `TaskKind::Deposit`, `Event::OreDeposited`, and new constant

In `crates/sim_core/src/types.rs`:

```rust
// In TaskKind, add after Mine:
Deposit {
    station: StationId,
},
```

```rust
// In Event, add after OreMined:
OreDeposited {
    station_id: StationId,
    deposited: HashMap<ElementId, f32>,
},
```

```rust
// In Constants, add after mining_rate_kg_per_tick:
pub deposit_ticks: u64,
```

### Step 2: Write the failing tests

In `crates/sim_core/src/lib.rs`, add:

```rust
fn deposit_command(state: &GameState) -> CommandEnvelope {
    let ship_id = ShipId("ship_0001".to_string());
    let station_id = StationId("station_earth_orbit".to_string());
    let ship = &state.ships[&ship_id];
    CommandEnvelope {
        id: CommandId("cmd_deposit_001".to_string()),
        issued_by: ship.owner.clone(),
        issued_tick: state.meta.tick,
        execute_at_tick: state.meta.tick,
        command: Command::AssignShipTask {
            ship_id,
            task_kind: TaskKind::Deposit { station: station_id },
        },
    }
}

#[test]
fn test_deposit_moves_cargo_to_station() {
    let content = test_content();
    let mut state = test_state(&content);
    let mut rng = make_rng();

    // Manually put ore in the ship's hold.
    let ship_id = ShipId("ship_0001".to_string());
    state.ships.get_mut(&ship_id).unwrap().cargo.insert("Fe".to_string(), 100.0);

    // Assign deposit task (deposit_ticks=1 in test_content).
    let cmd = deposit_command(&state);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);

    let station_id = StationId("station_earth_orbit".to_string());
    let station_fe = state.stations[&station_id].cargo.get("Fe").copied().unwrap_or(0.0);
    assert!((station_fe - 100.0).abs() < 1e-3, "Fe should transfer to station");
}

#[test]
fn test_deposit_clears_ship_cargo() {
    let content = test_content();
    let mut state = test_state(&content);
    let mut rng = make_rng();

    let ship_id = ShipId("ship_0001".to_string());
    state.ships.get_mut(&ship_id).unwrap().cargo.insert("Fe".to_string(), 100.0);

    let cmd = deposit_command(&state);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);

    let cargo = &state.ships[&ship_id].cargo;
    let total: f32 = cargo.values().sum();
    assert!(total < 1e-3, "ship cargo should be empty after deposit");
}

#[test]
fn test_deposit_emits_ore_deposited_event() {
    let content = test_content();
    let mut state = test_state(&content);
    let mut rng = make_rng();

    let ship_id = ShipId("ship_0001".to_string());
    state.ships.get_mut(&ship_id).unwrap().cargo.insert("Fe".to_string(), 50.0);

    let cmd = deposit_command(&state);
    tick(&mut state, &[cmd], &content, &mut rng, EventLevel::Normal);
    let events = tick(&mut state, &[], &content, &mut rng, EventLevel::Normal);

    assert!(
        events.iter().any(|e| matches!(e.event, Event::OreDeposited { .. })),
        "OreDeposited event should be emitted"
    );
}
```

**Step 3: Run to confirm they fail**

```bash
~/.cargo/bin/cargo test test_deposit 2>&1 | tail -5
```

Expected: compile errors — `Deposit` variant and `OreDeposited` event not defined.

### Step 4: Update task helpers for Deposit

In `crates/sim_core/src/tasks.rs`:

```rust
// In task_duration:
TaskKind::Deposit { .. } => constants.deposit_ticks,
```

```rust
// In task_kind_label:
TaskKind::Deposit { .. } => "Deposit",
```

```rust
// In task_target:
TaskKind::Deposit { station } => Some(station.0.clone()),
```

### Step 5: Add `resolve_deposit`

In `crates/sim_core/src/tasks.rs`, add after `resolve_mine`:

```rust
pub(crate) fn resolve_deposit(
    state: &mut GameState,
    ship_id: &ShipId,
    station_id: &StationId,
    events: &mut Vec<EventEnvelope>,
) {
    let current_tick = state.meta.tick;

    let Some(ship) = state.ships.get(ship_id) else { return };
    let cargo = ship.cargo.clone();

    if cargo.is_empty() {
        set_ship_idle(state, ship_id, current_tick);
        return;
    }

    let Some(station) = state.stations.get_mut(station_id) else {
        set_ship_idle(state, ship_id, current_tick);
        return;
    };

    // Transfer all ship cargo to the station (uncapped for now — station is large).
    for (element_id, kg) in &cargo {
        *station.cargo.entry(element_id.clone()).or_insert(0.0) += kg;
    }

    // Clear ship cargo.
    if let Some(ship) = state.ships.get_mut(ship_id) {
        ship.cargo.clear();
    }

    events.push(crate::emit(
        &mut state.counters,
        current_tick,
        Event::OreDeposited {
            station_id: station_id.clone(),
            deposited: cargo,
        },
    ));

    set_ship_idle(state, ship_id, current_tick);

    events.push(crate::emit(
        &mut state.counters,
        current_tick,
        Event::TaskCompleted {
            ship_id: ship_id.clone(),
            task_kind: "Deposit".to_string(),
            target: Some(station_id.0.clone()),
        },
    ));
}
```

### Step 6: Wire up Deposit in the engine

In `crates/sim_core/src/engine.rs`:

Add `resolve_deposit` to the imports:
```rust
use crate::tasks::{
    deep_scan_enabled, resolve_deep_scan, resolve_deposit, resolve_mine, resolve_survey,
    resolve_transit, task_duration, task_kind_label, task_target,
};
```

In `resolve_ship_tasks` match, add:
```rust
TaskKind::Deposit { ref station } => {
    resolve_deposit(state, &ship_id, station, events);
}
```

### Step 7: Update constants

In `content/constants.json`, add:
```json
"deposit_ticks": 60,
```

In `crates/sim_core/src/lib.rs` `test_content()` Constants, add:
```rust
deposit_ticks: 1,   // fast for tests
```

In `crates/sim_daemon/src/main.rs` `make_test_state()` Constants, add:
```rust
deposit_ticks: 1,
```

### Step 8: Run tests

```bash
~/.cargo/bin/cargo test 2>&1 | tail -10
```

Expected: all tests pass.

### Step 9: Commit

```bash
git add crates/sim_core/src/types.rs crates/sim_core/src/tasks.rs \
        crates/sim_core/src/engine.rs crates/sim_core/src/lib.rs \
        crates/sim_daemon/src/main.rs content/constants.json
git commit -m "feat(sim): add Deposit task — transfers ship cargo to station inventory"
```

---

## Task 6: Autopilot mining loop

**Files:**
- Modify: `crates/sim_control/src/lib.rs`

### Step 1: Write the failing test

In `crates/sim_control/src/lib.rs`, add a test module at the bottom:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use sim_core::{
        AnomalyTag, AsteroidId, AsteroidKnowledge, AsteroidState, CommandId, Constants, Counters,
        ElementDef, EventEnvelope, FacilitiesState, GameContent, GameState, MetaState, NodeDef,
        NodeId, PrincipalId, ResearchState, ScanSite, ShipId, ShipState, SiteId, SolarSystemDef,
        StationId, StationState, TechDef,
    };
    use std::collections::{HashMap, HashSet};

    fn autopilot_content() -> GameContent {
        GameContent {
            content_version: "test".to_string(),
            techs: vec![],
            solar_system: SolarSystemDef {
                nodes: vec![NodeDef { id: NodeId("node_a".to_string()), name: "A".to_string() }],
                edges: vec![],
            },
            asteroid_templates: vec![],
            elements: vec![
                ElementDef { id: "Fe".to_string(), density_kg_per_m3: 7874.0, display_name: "Iron".to_string() },
            ],
            constants: Constants {
                survey_scan_ticks: 1,
                deep_scan_ticks: 1,
                travel_ticks_per_hop: 1,
                survey_scan_data_amount: 1.0,
                survey_scan_data_quality: 1.0,
                deep_scan_data_amount: 1.0,
                deep_scan_data_quality: 1.0,
                survey_tag_detection_probability: 1.0,
                asteroid_count_per_template: 0,
                station_compute_units_total: 0,
                station_power_per_compute_unit_per_tick: 0.0,
                station_efficiency: 1.0,
                station_power_available_per_tick: 0.0,
                asteroid_mass_min_kg: 500.0,
                asteroid_mass_max_kg: 500.0,
                ship_cargo_capacity_m3: 20.0,
                station_cargo_capacity_m3: 10_000.0,
                mining_rate_kg_per_tick: 50.0,
                deposit_ticks: 1,
            },
        }
    }

    fn autopilot_state(content: &GameContent) -> GameState {
        let node = NodeId("node_a".to_string());
        let ship_id = ShipId("ship_0001".to_string());
        let station_id = StationId("station_earth_orbit".to_string());
        let owner = PrincipalId(AUTOPILOT_OWNER.to_string());
        GameState {
            meta: MetaState { tick: 0, seed: 0, schema_version: 1, content_version: "test".to_string() },
            scan_sites: vec![],
            asteroids: HashMap::new(),
            ships: HashMap::from([(
                ship_id.clone(),
                ShipState {
                    id: ship_id,
                    location_node: node.clone(),
                    owner,
                    cargo: HashMap::new(),
                    cargo_capacity_m3: content.constants.ship_cargo_capacity_m3,
                    task: None,
                },
            )]),
            stations: HashMap::from([(
                station_id.clone(),
                StationState {
                    id: station_id,
                    location_node: node,
                    power_available_per_tick: 0.0,
                    cargo: HashMap::new(),
                    cargo_capacity_m3: content.constants.station_cargo_capacity_m3,
                    facilities: FacilitiesState {
                        compute_units_total: 0,
                        power_per_compute_unit_per_tick: 0.0,
                        efficiency: 1.0,
                    },
                },
            )]),
            research: ResearchState {
                unlocked: HashSet::new(),
                data_pool: HashMap::new(),
                evidence: HashMap::new(),
            },
            counters: Counters { next_event_id: 0, next_command_id: 0, next_asteroid_id: 0 },
        }
    }

    #[test]
    fn test_autopilot_assigns_mine_when_asteroid_known() {
        let content = autopilot_content();
        let mut state = autopilot_state(&content);

        // Add a deep-scanned asteroid at the same node.
        let asteroid_id = AsteroidId("asteroid_0001".to_string());
        state.asteroids.insert(asteroid_id.clone(), AsteroidState {
            id: asteroid_id.clone(),
            location_node: NodeId("node_a".to_string()),
            true_composition: HashMap::from([("Fe".to_string(), 1.0)]),
            anomaly_tags: vec![],
            mass_kg: 500.0,
            knowledge: AsteroidKnowledge {
                tag_beliefs: vec![],
                composition: Some(HashMap::from([("Fe".to_string(), 1.0)])),
            },
        });

        let mut autopilot = AutopilotController;
        let mut next_id = 0u64;
        let commands = autopilot.generate_commands(&state, &content, &mut next_id);

        assert!(
            commands.iter().any(|cmd| matches!(
                &cmd.command,
                sim_core::Command::AssignShipTask { task_kind: TaskKind::Mine { .. }, .. }
            )),
            "autopilot should assign Mine task when deep-scanned asteroid is available"
        );
    }

    #[test]
    fn test_autopilot_assigns_deposit_when_ship_has_cargo() {
        let content = autopilot_content();
        let mut state = autopilot_state(&content);

        // Put cargo in the ship.
        let ship_id = ShipId("ship_0001".to_string());
        state.ships.get_mut(&ship_id).unwrap().cargo.insert("Fe".to_string(), 100.0);

        let mut autopilot = AutopilotController;
        let mut next_id = 0u64;
        let commands = autopilot.generate_commands(&state, &content, &mut next_id);

        assert!(
            commands.iter().any(|cmd| matches!(
                &cmd.command,
                sim_core::Command::AssignShipTask { task_kind: TaskKind::Deposit { .. }, .. }
                    | sim_core::Command::AssignShipTask {
                        task_kind: TaskKind::Transit { then, .. }, ..
                    } if matches!(then.as_ref(), TaskKind::Deposit { .. })
            )),
            "autopilot should assign Deposit when ship has cargo"
        );
    }
}
```

**Step 2: Run to confirm they fail**

```bash
~/.cargo/bin/cargo test -p sim_control 2>&1 | tail -5
```

Expected: compile errors — `Mine` and `Deposit` are new imports needed.

### Step 3: Extend the autopilot

Replace the body of `generate_commands` in `crates/sim_control/src/lib.rs`:

```rust
fn generate_commands(
    &mut self,
    state: &GameState,
    content: &GameContent,
    next_command_id: &mut u64,
) -> Vec<CommandEnvelope> {
    use std::cmp::Ordering;

    let owner = PrincipalId(AUTOPILOT_OWNER.to_string());

    // Collect idle autopilot ships, sorted for determinism.
    let mut idle_ships: Vec<_> = state
        .ships
        .values()
        .filter(|ship| {
            ship.owner == owner
                && ship
                    .task
                    .as_ref()
                    .is_none_or(|t| matches!(t.kind, TaskKind::Idle))
        })
        .map(|ship| ship.id.clone())
        .collect();
    idle_ships.sort_by(|a, b| a.0.cmp(&b.0));

    let deep_scan_unlocked = state
        .research
        .unlocked
        .contains(&TechId("tech_deep_scan_v1".to_string()));

    // Survey candidates.
    let mut next_site = state.scan_sites.iter();

    // Deep scan candidates: IronRich confidence above threshold, composition unknown.
    let mut deep_scan_candidates: Vec<AsteroidId> = state
        .asteroids
        .values()
        .filter(|asteroid| {
            asteroid.knowledge.composition.is_none()
                && asteroid.knowledge.tag_beliefs.iter().any(|(tag, conf)| {
                    *tag == AnomalyTag::IronRich && *conf > IRON_RICH_CONFIDENCE_THRESHOLD
                })
        })
        .map(|a| a.id.clone())
        .collect();
    deep_scan_candidates.sort_by(|a, b| a.0.cmp(&b.0));
    let mut next_deep_scan = deep_scan_candidates.iter();

    // Mine candidates: deep-scanned, has remaining mass, sorted by value desc.
    let mut mine_candidates: Vec<&AsteroidState> = state
        .asteroids
        .values()
        .filter(|a| a.mass_kg > 0.0 && a.knowledge.composition.is_some())
        .collect();
    mine_candidates.sort_by(|a, b| {
        let value = |ast: &&AsteroidState| {
            ast.mass_kg
                * ast
                    .knowledge
                    .composition
                    .as_ref()
                    .and_then(|c| c.get("Fe"))
                    .copied()
                    .unwrap_or(0.0)
        };
        value(b)
            .partial_cmp(&value(a))
            .unwrap_or(Ordering::Equal)
    });
    let mut next_mine = mine_candidates.iter();

    let mut commands = Vec::new();

    for ship_id in idle_ships {
        let ship = &state.ships[&ship_id];

        // Priority 1: ship has cargo → deposit at nearest station.
        if !ship.cargo.is_empty() {
            let Some(station) = state
                .stations
                .values()
                .min_by_key(|s| {
                    shortest_hop_count(&ship.location_node, &s.location_node, &content.solar_system)
                        .unwrap_or(u64::MAX)
                })
            else {
                continue;
            };

            let deposit_task = TaskKind::Deposit { station: station.id.clone() };
            let final_task = match shortest_hop_count(
                &ship.location_node,
                &station.location_node,
                &content.solar_system,
            ) {
                Some(0) | None => deposit_task,
                Some(hops) => TaskKind::Transit {
                    destination: station.location_node.clone(),
                    total_ticks: hops * content.constants.travel_ticks_per_hop,
                    then: Box::new(deposit_task),
                },
            };

            let cmd_id = CommandId(format!("cmd_{:06}", *next_command_id));
            *next_command_id += 1;
            commands.push(CommandEnvelope {
                id: cmd_id,
                issued_by: ship.owner.clone(),
                issued_tick: state.meta.tick,
                execute_at_tick: state.meta.tick,
                command: Command::AssignShipTask { ship_id, task_kind: final_task },
            });
            continue;
        }

        // Priority 2: unscanned survey sites.
        if let Some(site) = next_site.next() {
            let target_node = site.node.clone();
            let task_kind = TaskKind::Survey { site: SiteId(site.id.0.clone()) };
            let final_task = match shortest_hop_count(
                &ship.location_node,
                &target_node,
                &content.solar_system,
            ) {
                Some(0) | None => task_kind,
                Some(hops) => TaskKind::Transit {
                    destination: target_node,
                    total_ticks: hops * content.constants.travel_ticks_per_hop,
                    then: Box::new(task_kind),
                },
            };
            let cmd_id = CommandId(format!("cmd_{:06}", *next_command_id));
            *next_command_id += 1;
            commands.push(CommandEnvelope {
                id: cmd_id,
                issued_by: ship.owner.clone(),
                issued_tick: state.meta.tick,
                execute_at_tick: state.meta.tick,
                command: Command::AssignShipTask { ship_id, task_kind: final_task },
            });
            continue;
        }

        // Priority 3: deep scan.
        if deep_scan_unlocked {
            if let Some(asteroid_id) = next_deep_scan.next() {
                let node = state.asteroids[asteroid_id].location_node.clone();
                let task_kind = TaskKind::DeepScan { asteroid: asteroid_id.clone() };
                let final_task = match shortest_hop_count(
                    &ship.location_node,
                    &node,
                    &content.solar_system,
                ) {
                    Some(0) | None => task_kind,
                    Some(hops) => TaskKind::Transit {
                        destination: node,
                        total_ticks: hops * content.constants.travel_ticks_per_hop,
                        then: Box::new(task_kind),
                    },
                };
                let cmd_id = CommandId(format!("cmd_{:06}", *next_command_id));
                *next_command_id += 1;
                commands.push(CommandEnvelope {
                    id: cmd_id,
                    issued_by: ship.owner.clone(),
                    issued_tick: state.meta.tick,
                    execute_at_tick: state.meta.tick,
                    command: Command::AssignShipTask { ship_id, task_kind: final_task },
                });
                continue;
            }
        }

        // Priority 4: mine best available asteroid.
        if let Some(asteroid) = next_mine.next() {
            let target_node = asteroid.location_node.clone();
            let duration_ticks = sim_core::mine_duration(asteroid, ship, content);
            let task_kind = TaskKind::Mine { asteroid: asteroid.id.clone(), duration_ticks };
            let final_task = match shortest_hop_count(
                &ship.location_node,
                &target_node,
                &content.solar_system,
            ) {
                Some(0) | None => task_kind,
                Some(hops) => TaskKind::Transit {
                    destination: target_node,
                    total_ticks: hops * content.constants.travel_ticks_per_hop,
                    then: Box::new(task_kind),
                },
            };
            let cmd_id = CommandId(format!("cmd_{:06}", *next_command_id));
            *next_command_id += 1;
            commands.push(CommandEnvelope {
                id: cmd_id,
                issued_by: ship.owner.clone(),
                issued_tick: state.meta.tick,
                execute_at_tick: state.meta.tick,
                command: Command::AssignShipTask { ship_id, task_kind: final_task },
            });
            continue;
        }
        // Nothing to do for this ship.
    }

    commands
}
```

Also update the imports at the top of the file to include `AsteroidState`, `StationId`, `mine_duration`:

```rust
use sim_core::{
    shortest_hop_count, mine_duration, AnomalyTag, AsteroidId, AsteroidState, Command,
    CommandEnvelope, CommandId, GameContent, GameState, PrincipalId, SiteId, StationId,
    TaskKind, TechId,
};
```

### Step 4: Run tests

```bash
~/.cargo/bin/cargo test 2>&1 | tail -10
```

Expected: all tests pass including the two new autopilot tests.

### Step 5: Commit

```bash
git add crates/sim_control/src/lib.rs
git commit -m "feat(sim): extend autopilot with mine/deposit loop"
```

---

## Task 7: FE resizable panels and table scroll

**Files:**
- Modify: `ui_web/package.json` (new dep)
- Modify: `ui_web/src/App.tsx`
- Modify: `ui_web/src/components/AsteroidTable.tsx`
- Modify: `ui_web/src/components/EventsFeed.tsx`

### Step 1: Install the library

From `ui_web/`:

```bash
npm install react-resizable-panels
```

### Step 2: Write a failing test

In `ui_web/src/App.test.tsx`, add:

```tsx
it('renders resize handles between panels', () => {
  render(<App />)
  // react-resizable-panels renders [data-panel-resize-handle-id] attributes
  const handles = document.querySelectorAll('[data-panel-resize-handle-id]')
  expect(handles.length).toBeGreaterThan(0)
})
```

**Run to confirm it fails:**

```bash
npm test -- --run 2>&1 | tail -10
```

Expected: test fails — no resize handles found.

### Step 3: Update `App.tsx` to use resizable panels

```tsx
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels'
import { AsteroidTable } from './components/AsteroidTable'
import { EventsFeed } from './components/EventsFeed'
import { ResearchPanel } from './components/ResearchPanel'
import { StatusBar } from './components/StatusBar'
import { useSimStream } from './hooks/useSimStream'

export default function App() {
  const { snapshot, events, connected, currentTick } = useSimStream()

  return (
    <div className="flex flex-col h-screen overflow-hidden">
      <StatusBar tick={currentTick} connected={connected} />
      <PanelGroup direction="horizontal" className="flex-1 overflow-hidden">
        <Panel defaultSize={25} minSize={12}>
          <section className="flex flex-col h-full overflow-hidden bg-void p-3">
            <h2 className="text-[11px] uppercase tracking-widest text-label mb-2 pb-1.5 border-b border-edge shrink-0">Events</h2>
            <EventsFeed events={events} />
          </section>
        </Panel>
        <PanelResizeHandle className="w-px bg-edge hover:bg-dim cursor-col-resize transition-colors" />
        <Panel defaultSize={50} minSize={20}>
          <section className="flex flex-col h-full overflow-hidden bg-void p-3">
            <h2 className="text-[11px] uppercase tracking-widest text-label mb-2 pb-1.5 border-b border-edge shrink-0">Asteroids</h2>
            <AsteroidTable asteroids={snapshot?.asteroids ?? {}} />
          </section>
        </Panel>
        <PanelResizeHandle className="w-px bg-edge hover:bg-dim cursor-col-resize transition-colors" />
        <Panel defaultSize={25} minSize={12}>
          <section className="flex flex-col h-full overflow-hidden bg-void p-3">
            <h2 className="text-[11px] uppercase tracking-widest text-label mb-2 pb-1.5 border-b border-edge shrink-0">Research</h2>
            {snapshot && <ResearchPanel research={snapshot.research} />}
          </section>
        </Panel>
      </PanelGroup>
    </div>
  )
}
```

### Step 4: Make tables horizontally scrollable

In `ui_web/src/components/AsteroidTable.tsx`, change the outer div from `overflow-y-auto` to `overflow-auto`, and add `min-w-max` to the table:

```tsx
<div className="overflow-auto flex-1">
  <table className="w-full min-w-max border-collapse text-[11px]">
```

Apply the same `overflow-auto` to the list in `EventsFeed.tsx` (it already scrolls correctly, but make sure the column layout doesn't clip):

In `EventsFeed.tsx`, the row div already has `overflow-hidden text-ellipsis whitespace-nowrap` on the detail span — this is fine for the events list (it's intentionally clipped with ellipsis). No change needed.

### Step 5: Run tests

```bash
cd ui_web && npm test -- --run 2>&1 | tail -10
```

Expected: all tests pass.

### Step 6: Commit

```bash
git add ui_web/package.json ui_web/package-lock.json \
        ui_web/src/App.tsx ui_web/src/components/AsteroidTable.tsx
git commit -m "feat(ui): resizable panels and horizontal scroll on asteroid table"
```

---

## Task 8: FE mining data display

**Files:**
- Modify: `ui_web/src/types.ts`
- Modify: `ui_web/src/components/AsteroidTable.tsx`
- Create: `ui_web/src/components/FleetPanel.tsx`
- Create: `ui_web/src/components/FleetPanel.test.tsx`
- Modify: `ui_web/src/App.tsx`

### Step 1: Update `types.ts`

```typescript
export interface TaskState {
  kind:
    | { Idle: Record<string, never> }
    | { Survey: { site: string } }
    | { DeepScan: { asteroid: string } }
    | { Mine: { asteroid: string; duration_ticks: number } }
    | { Deposit: { station: string } }
    | { Transit: { destination: string; total_ticks: number } }
  started_tick: number
  eta_tick: number
}

export interface ShipState {
  id: string
  location_node: string
  owner: string
  cargo: Record<string, number>       // element_id -> kg
  cargo_capacity_m3: number
  task: TaskState | null
}

export interface StationState {
  id: string
  location_node: string
  power_available_per_tick: number
  cargo: Record<string, number>       // element_id -> kg
  cargo_capacity_m3: number
  facilities: FacilitiesState
}

export interface AsteroidState {
  id: string
  location_node: string
  anomaly_tags: string[]
  mass_kg: number
  knowledge: AsteroidKnowledge
}
```

### Step 2: Add `mass_kg` column to `AsteroidTable`

In `ui_web/src/components/AsteroidTable.tsx`, add a Mass column:

```tsx
// In thead:
<th className="text-left text-label px-2 py-1 border-b border-edge font-normal">Mass</th>

// In tbody rows:
<td className="px-2 py-0.5 border-b border-surface">
  {asteroid.mass_kg > 0 ? `${asteroid.mass_kg.toLocaleString(undefined, { maximumFractionDigits: 0 })} kg` : <span className="text-faint">depleted</span>}
</td>
```

### Step 3: Write a failing test for `FleetPanel`

Create `ui_web/src/components/FleetPanel.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { FleetPanel } from './FleetPanel'
import type { ShipState } from '../types'

const mockShip: ShipState = {
  id: 'ship_0001',
  location_node: 'node_earth_orbit',
  owner: 'principal_autopilot',
  cargo: { Fe: 150.0, Si: 30.0 },
  cargo_capacity_m3: 20.0,
  task: null,
}

it('renders ship id', () => {
  render(<FleetPanel ships={{ ship_0001: mockShip }} />)
  expect(screen.getByText(/ship_0001/)).toBeInTheDocument()
})

it('renders cargo elements', () => {
  render(<FleetPanel ships={{ ship_0001: mockShip }} />)
  expect(screen.getByText(/Fe/)).toBeInTheDocument()
})

it('renders empty state when no ships', () => {
  render(<FleetPanel ships={{}} />)
  expect(screen.getByText(/no ships/i)).toBeInTheDocument()
})
```

**Run to confirm it fails:**

```bash
npm test -- --run 2>&1 | tail -10
```

Expected: cannot find module `./FleetPanel`.

### Step 4: Create `FleetPanel` component

Create `ui_web/src/components/FleetPanel.tsx`:

```tsx
import type { ShipState } from '../types'

interface Props {
  ships: Record<string, ShipState>
}

function taskLabel(task: ShipState['task']): string {
  if (!task) return 'idle'
  const key = Object.keys(task.kind)[0] ?? 'idle'
  return key.toLowerCase()
}

function cargoVolume(cargo: Record<string, number>): number {
  // Display total mass; volume requires density lookup which isn't in FE yet.
  return Object.values(cargo).reduce((sum, kg) => sum + kg, 0)
}

export function FleetPanel({ ships }: Props) {
  const rows = Object.values(ships)

  if (rows.length === 0) {
    return (
      <div className="overflow-y-auto flex-1">
        <div className="text-faint italic">no ships</div>
      </div>
    )
  }

  return (
    <div className="overflow-y-auto flex-1">
      {rows.map((ship) => {
        const totalCargo = cargoVolume(ship.cargo)
        const hasCargo = totalCargo > 0

        return (
          <div key={ship.id} className="py-1.5 border-b border-surface text-[11px]">
            <div className="text-bright mb-0.5">{ship.id}</div>
            <div className="text-dim">{ship.location_node} · {taskLabel(ship.task)}</div>
            {hasCargo ? (
              <div className="mt-0.5">
                <div className="text-muted mb-0.5">
                  cargo: {totalCargo.toLocaleString(undefined, { maximumFractionDigits: 1 })} kg
                </div>
                <div className="flex flex-wrap gap-x-2 text-accent">
                  {Object.entries(ship.cargo).map(([element, kg]) => (
                    <span key={element}>{element} {kg.toFixed(1)}</span>
                  ))}
                </div>
              </div>
            ) : (
              <div className="text-faint mt-0.5">hold empty</div>
            )}
          </div>
        )
      })}
    </div>
  )
}
```

### Step 5: Add Fleet panel to `App.tsx`

Add a fourth panel between Asteroids and Research:

```tsx
import { FleetPanel } from './components/FleetPanel'

// In PanelGroup, change defaultSizes and add panel:
<Panel defaultSize={20} minSize={12}>
  <section className="flex flex-col h-full overflow-hidden bg-void p-3">
    <h2 ...>Fleet</h2>
    <FleetPanel ships={snapshot?.ships ?? {}} />
  </section>
</Panel>
<PanelResizeHandle className="w-px bg-edge hover:bg-dim cursor-col-resize transition-colors" />
<Panel defaultSize={20} minSize={12}>
  <section ...>
    <h2 ...>Research</h2>
    ...
  </section>
</Panel>
```

Adjust the four panel `defaultSize` values to sum to 100: e.g. Events 20, Asteroids 40, Fleet 20, Research 20.

### Step 6: Update `App.test.tsx` to expect four headings

In `App.test.tsx`, update the headings test to include Fleet:

```tsx
it('renders all four panel headings', () => {
  render(<App />)
  expect(screen.getByText('Events')).toBeInTheDocument()
  expect(screen.getByText('Asteroids')).toBeInTheDocument()
  expect(screen.getByText('Fleet')).toBeInTheDocument()
  expect(screen.getByText('Research')).toBeInTheDocument()
})
```

### Step 7: Run all tests

```bash
npm test -- --run 2>&1 | tail -10
```

Expected: all tests pass.

### Step 8: Commit

```bash
git add ui_web/src/types.ts ui_web/src/components/AsteroidTable.tsx \
        ui_web/src/components/FleetPanel.tsx ui_web/src/components/FleetPanel.test.tsx \
        ui_web/src/App.tsx ui_web/src/App.test.tsx
git commit -m "feat(ui): add mass column, fleet panel with cargo, update types for mining"
```

---

## Final verification

After all 8 tasks, run the full test suite:

```bash
# Rust
~/.cargo/bin/cargo test

# React
cd ui_web && npm test -- --run
```

Expected: all Rust tests pass (28 existing + ~15 new), all React tests pass (29 existing + ~5 new).
